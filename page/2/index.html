<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jimmy的日记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录我职业生涯的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Jimmy的日记">
<meta property="og:url" content="http://JimmyYao984.github.io/page/2/index.html">
<meta property="og:site_name" content="Jimmy的日记">
<meta property="og:description" content="记录我职业生涯的点点滴滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jimmy的日记">
<meta name="twitter:description" content="记录我职业生涯的点点滴滴">
  
    <link rel="alternate" href="/atom.xml" title="Jimmy的日记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jimmy的日记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">study new skill step by step</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://JimmyYao984.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JVM学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/10/JVM学习笔记/" class="article-date">
  <time datetime="2016-06-09T17:07:22.000Z" itemprop="datePublished">2016-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/10/JVM学习笔记/">JVM学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整数的表达"><a href="#整数的表达" class="headerlink" title="整数的表达"></a>整数的表达</h2><p>在计算机系统中，数值一律用补码来表示和存储。<br>原因在于，使用补码，可以将符号位和数值域统一处理；<br>同时，加法和减法也可以统一处理。<br>此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p>
<ul>
<li>原码——第一位为符号位（0为整数，1为负数）</li>
<li>反码——符号位不懂，原码取反</li>
<li>负数补码——符号为不动，反码加1</li>
<li>正数补码——和原码相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印整数的二进制表示</span></span><br><span class="line"><span class="keyword">int</span> a = -<span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">int</span> t = (a &amp; <span class="number">0x80000000</span>&gt;&gt;&gt;i)&gt;&gt;&gt;(<span class="number">31</span>-i);</span><br><span class="line">   System.out.print(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br> <br> <br></p>
<h2 id="JVM需要对Java-Library提供以下支持"><a href="#JVM需要对Java-Library提供以下支持" class="headerlink" title="JVM需要对Java Library提供以下支持"></a>JVM需要对Java Library提供以下支持</h2><ul>
<li>反射java.lang.reflect</li>
<li>ClassLoader</li>
<li>初始化class和interface</li>
<li>安全相关java.security</li>
<li>多线程</li>
<li>弱引用<br><br> <br> <br></li>
</ul>
<h2 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h2><p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606100140.png" alt="Mark-Down"></p>
<p><br> <br> <br></p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606101524.png" alt="Mark-Down"></p>
<p>Java栈是线程私有的，Java堆是全局共享的。</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>每个线程拥有一个PC寄存器<br>在线程创建时创建<br>指向下一条指令的地址<br>执行本地方法时，PC的值为undefined</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>保存装载的类信息</p>
<ul>
<li>类型的常量池</li>
<li>字段，方法信息</li>
<li>方法字节码<br>通常和永久区（Perm）关联在一起<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3>和程序开发密切相关<br>应用系统对象都保存在Java堆中<br>所有线程共享Java堆<br>对分代GC来说，堆也是分代的<br>GC的主要工作区间<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606102021.png" alt="Mark-Down"></li>
</ul>
<h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>线程私有<br>栈由一系列帧组成（因此Java栈也叫做帧栈）<br>帧保存一个方法的局部变量、操作数栈、常量池指针<br>每一个方法调用创建一个帧，并压栈<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStatic</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> l, <span class="keyword">float</span> f, Object o, <span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">runInstance</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">short</span> s, <span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606102053.png" alt="Mark-Down"></p>
<p><br> <br> <br></p>
<h2 id="Java栈上分配"><a href="#Java栈上分配" class="headerlink" title="Java栈上分配"></a>Java栈上分配</h2><p>小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上<br>直接分配在栈上，可以自动回收，减轻GC压力<br>大对象或者逃逸对象无法栈上分配<br><br> <br> <br></p>
<h2 id="栈、堆、方法区交互"><a href="#栈、堆、方法区交互" class="headerlink" title="栈、堆、方法区交互"></a>栈、堆、方法区交互</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span></span>&#123; <span class="comment">//运行时，jvm把appmain的信息都放入方法区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">//main方法本身放入方法区</span></span><br><span class="line">        Sample test1 = <span class="keyword">new</span> Sample(<span class="string">"测试1"</span>); <span class="comment">//test1引用，所以放到栈区，Sample是自定义对象应该放到堆里面</span></span><br><span class="line">        Sample test2 = <span class="keyword">new</span> Sample(<span class="string">"测试2"</span>);</span><br><span class="line"></span><br><span class="line">        test1.printName();</span><br><span class="line">        test2.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123; <span class="comment">//运行时，jvm把appmain的信息都放入方法区</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//new Sample实例后，name引用放入栈区里name对象放入堆里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sample</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print方法本身放入方法区里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606112339.png" alt="Mark-Down"></p>
<p><br><br> <br></p>
<h2 id="工作内存和主存"><a href="#工作内存和主存" class="headerlink" title="工作内存和主存"></a>工作内存和主存</h2><p>当数据从主内存复制到工作存储时，必须出现两个动作</p>
<ul>
<li>由主内存执行的读（read）操作</li>
<li>由工作内存执行的相应的load操作<br><br><br>当数据从工作内存拷贝到主内存时，也出现两个操作</li>
<li>由工作内存执行的存储(store)操作</li>
<li>由主内存执行的相应的写(write)操作<br><br><br>每一个操作都是原子的，即执行期间不会被中断<br>对于普通变量，一个线程中更新的值，不能马上反应在其他变量中<br>如果需要在其他线程中立即可见，需要使用volatile关键字<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606120126.png" alt="Mark-Down"></li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul>
<li>在本线程内，操作都是有序的</li>
<li>在线程外观察，操作都是无序的。（指令重排或主内存同步延时）<br><br><h4 id="指令重排的基本原则"><a href="#指令重排的基本原则" class="headerlink" title="指令重排的基本原则"></a>指令重排的基本原则</h4></li>
<li>程序顺序原则：一个线程内保证语义的串行性</li>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁（unlock）必然发生在随后的加锁（lock）前</li>
<li>传递性：A先于B，B先于C，那么A必然先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结（Thread.join()）</li>
<li>线程的中断（interrupt()）先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法<br><br> <br> <br><h2 id="几种常见的GC算法"><a href="#几种常见的GC算法" class="headerlink" title="几种常见的GC算法"></a>几种常见的GC算法</h2></li>
<li>引用计数法</li>
<li>标记-清除法</li>
<li>标记-压缩法</li>
<li>复制算法<br><br><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4>老牌垃圾回收算法<br>通过引用计数来回收垃圾<br>使用者：COM、ActionScript3、Python<br>缺陷：引用和去引用伴随加法和减法，影响性能；很难处理循环引用问题<br><br><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4>标记阶段：通过根节点，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象。<br>清除阶段：清除所有未被标记的对象。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122214.png" alt="Mark-Down"></li>
</ul>
<p><br></p>
<h4 id="标记-压缩"><a href="#标记-压缩" class="headerlink" title="标记-压缩"></a>标记-压缩</h4><p>它是标记-清除的优化，先标记，但之后并不简单的清理未被标记的对象，而是将所有的存活对象压缩到内存的一端。<br>之后，清理边界外所有空间。这样做，减少了内存碎片。<br> [标记-压缩] 算法适用于存活对象较多的场合，如老年代。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122213.png" alt="Mark-Down"></p>
<p><br></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>与标记-清除算法相比，复制算法是一种相对高效的回收方法。<br>不适用于存活对象较多的场合，如老年代。<br>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，<br>之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122230.png" alt="Mark-Down"></p>
<p>复制算法的最大问题是：空间浪费 整合标记清理思想<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122233.png" alt="Mark-Down"></p>
<p><br></p>
<h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><ul>
<li>依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。</li>
<li>根据不同代的特点，选取合适的收集算法：少量对象存活，适合复制算法；大量对象存活，适合标记清理或标记压缩算法。<br><br><h4 id="可触及性"><a href="#可触及性" class="headerlink" title="可触及性"></a>可触及性</h4></li>
<li>可触及的：从根节点可以触及到这个对象</li>
<li>可复活的：一旦所有引用被释放，就是可复活状态，因为finalize()中可能复活该对象</li>
<li>不可触及的：在finalize()后，可能会进入不可触及状态，不可触及的对象不可能复活，可以回收<br>避免使用finalize(),操作不慎可能导致错误。可以使用try-catch-finally来替代它。<br><br></li>
</ul>
<h4 id="STOP-THE-WORLD"><a href="#STOP-THE-WORLD" class="headerlink" title="STOP_THE_WORLD"></a>STOP_THE_WORLD</h4><p>Java中一种全局暂停的现象。<br>全局停顿，所有Java代码停止，native可以执行，但不能和JVM交互。<br>多半由于GC引起。</p>
<ul>
<li>Dump线程</li>
<li>死锁检查</li>
<li>堆Dump<br>危害：长时间服务停止，没有响应；遇到HA系统，可能引起主备切换，严重危害生产环境。<br><br></li>
</ul>
<h2 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h2><h4 id="class装载验证流程"><a href="#class装载验证流程" class="headerlink" title="class装载验证流程"></a>class装载验证流程</h4><p>加载——&gt;链接[验证、准备、解析]——&gt;初始化</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>装载类的第一个阶段<br>取得类的二进制流<br>转为方法区数据结构<br>在Java堆中生成对应的java.lang.Class对象</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>目的：保证Class流的格式是正确的</p>
<ul>
<li>文件格式的验证</li>
<li>元数据验证</li>
<li>字节码验证（很复杂）</li>
<li>符号引用验证<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4>分配内存，并为类设置初始值（方法区中）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">1</span>; <span class="comment">//在准备阶段找那个，v会被设置为0，在初始化的&lt;clinit&gt;中才会被设置为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">1</span>; <span class="comment">//对于static final类型，在准备阶段就会被赋上正确的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>符号引用替换为直接引用。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行类构造器<clinit>,static变量赋值语句，static{}语句。<br>子类的<clinit>调用前保证父类的<clinit>被调用。</clinit></clinit></clinit></p>
<p><clinit>是线程安全的。<br><br></clinit></p>
<h2 id="什么是ClassLoader"><a href="#什么是ClassLoader" class="headerlink" title="什么是ClassLoader"></a>什么是ClassLoader</h2><p>ClassLoader是一个抽象<br>ClassLoader的实例将读入Java字节码将类装载到JVM中<br>ClassLoader可以定制，满足不同的字节码流获取方式<br>ClassLoader负责类装载过程中的加载阶段<br>ClassLoad的重要方法</p>
<ul>
<li>public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException 载入并返回一个Class</li>
<li>protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len) 定义一个类，不公开调用</li>
<li>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException loadClass回调方法，自定义ClassLoader的推荐做法</li>
<li>protected final Class&lt;?&gt; findLoadedClass(String name) 寻找已经加载的类</li>
</ul>
<h2 id="JDK中ClassLoader默认设计模式"><a href="#JDK中ClassLoader默认设计模式" class="headerlink" title="JDK中ClassLoader默认设计模式"></a>JDK中ClassLoader默认设计模式</h2><p>BootStrap ClassLoader(启动ClassLoader)<br>Extension ClassLoader(扩展ClassLoader)<br>App ClassLoader(应用ClassLoader/系统ClassLoader)<br>Custom ClassLoader(自定义ClassLoader)<br>每个ClassLoader都有一个Parent作为父亲。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122306.png" alt="Mark-Down"></p>
<p>双亲模式的问题：顶层ClassLoader，无法加载底层ClassLoader的类。<br>解决办法：Thread.setContextClassLoader()，上下文加载器，基本思想是，在顶层ClassLoader中，传入底层ClassLoader的实例。<br>双亲模式是默认的模式，但不是必须这么做，Tomcat的WebappClassLoader就会先加载自己的Class，找不到再委托parent；<br>OSGi的ClassLoader形成网状结构，根据需要自由加载Class。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/06/10/JVM学习笔记/" data-id="civ9ktzk80002jogf0texai7r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java核心技术阅读笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/07/Java核心技术阅读笔记/" class="article-date">
  <time datetime="2016-06-07T06:45:31.000Z" itemprop="datePublished">2016-06-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/07/Java核心技术阅读笔记/">Java核心技术阅读笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="在类之间，最常见的关系有："><a href="#在类之间，最常见的关系有：" class="headerlink" title="在类之间，最常见的关系有："></a>在类之间，最常见的关系有：</h4><ul>
<li>依赖(uses-a)</li>
<li>聚合(has-a)</li>
<li>继承(is-a)</li>
</ul>
<h4 id="订单系统"><a href="#订单系统" class="headerlink" title="订单系统"></a>订单系统</h4><ul>
<li>项目(Item)</li>
<li>订单(Order)</li>
<li>送货地址(Shipping address)</li>
<li>付款(Payment)</li>
<li>账户(Account)</li>
</ul>
<h4 id="表达类关系的UML符号"><a href="#表达类关系的UML符号" class="headerlink" title="表达类关系的UML符号"></a>表达类关系的UML符号</h4><p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606071512.png" alt="Mark-Down"></p>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606071534.png" alt="Mark-Down"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/06/07/Java核心技术阅读笔记/" data-id="civ9ktzjs0001jogfl2sarrbt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-2016大计划" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/27/2016大计划/" class="article-date">
  <time datetime="2016-05-26T17:59:49.000Z" itemprop="datePublished">2016-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/27/2016大计划/">2016大计划</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="2016已经快要过去一半-计划永远赶不上变化"><a href="#2016已经快要过去一半-计划永远赶不上变化" class="headerlink" title="2016已经快要过去一半 计划永远赶不上变化"></a>2016已经快要过去一半 计划永远赶不上变化</h2><ul>
<li>掌握前端技术</li>
<li>掌握后端技术</li>
</ul>
<h4 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h4><ul>
<li>会熟练使用html和css</li>
<li>掌握javascript</li>
<li>掌握js框架（了解angular、react、vue、jquery）</li>
<li>掌握前端自动化（glup webpack）</li>
</ul>
<h4 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h4><ul>
<li>精通J2EE</li>
<li>使用php搭建后台</li>
<li>掌握php框架</li>
<li>学会nodejs</li>
</ul>
<h4 id="电商项目"><a href="#电商项目" class="headerlink" title="电商项目"></a>电商项目</h4><p>完成网页前端和后端，时间允许在做手机端适配</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/05/27/2016大计划/" data-id="civ9ktzjc0000jogfos9smcat" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一步一步精通Java多线程4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/13/一步一步精通Java多线程4/" class="article-date">
  <time datetime="2016-05-13T03:02:38.000Z" itemprop="datePublished">2016-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/13/一步一步精通Java多线程4/">Java多线程 0x04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>创建线程执行器</li>
<li>创建固定大小的线程执行器</li>
<li>在执行器中执行任务并返回结果</li>
<li>运行多个任务并处理第一个结果</li>
<li>运行多个任务并处理所有结果</li>
<li>在执行器中延时执行任务</li>
<li>在执行器中周期性执行任务</li>
<li>在执行器中取消任务</li>
<li>在执行器中控制任务的完成</li>
<li>在执行器中分离任务的启动与结果的处理</li>
<li>处理在执行器中被拒绝的任务</li>
</ul>
<p>通常Java开发一个简单的并发任务，会创建Runnable对象，并创建对应的Thread的对象来执行它们。<br>但是，如果开发一个运行大量的并发任务，这个方法将突显以下劣势</p>
<ul>
<li>必须实现所有与Thread对象管理相关的代码，如线程的创建、结束以及结果获取。</li>
<li>需要为每个任务创建一个Thread对象。如果需要执行大量的任务，这将大大地影响应用程序的处理能力。</li>
<li>计算机的资源需要高效地进行控制和管理，创建过多的线程，将会导致系统负荷过重。</li>
</ul>
<p>自JDK5之后，Java并发API提供了一套执行器框架（Executor Framework），它围绕着Executor接口和它的子接口ExecutorService，以及实现这两个接口的ThreadPoolExecutor类展开。<br>这套机制分离了任务的创建和执行，通过使用执行器，仅需要实现Runnable接口的对象，然后将这些对象发送给执行器即可。<br>执行器通过创建所需的线程，来负责这些Runnable对象的创建、实例化以及运行。<br>执行器使用了线程池来提高应用程序的性能。当发送一个任务给执行器时，执行器会尝试使用线程池中的线程来执行这个任务，避免了不断地创建和销毁线程而导致系统性能下降。</p>
<p>执行器框架另一个重要的优势是Callable接口，它类似于Runnable接口，但提供了两方面的增加：</p>
<ul>
<li>接口主方法名为call()，可以返回结果</li>
<li>当发送一个Callable对象给执行器时，将获得一个实现了Future接口的对象。可以使用这个Future对象控制Callable对象的状态和结果。<br><br><br><h2 id="创建执行器"><a href="#创建执行器" class="headerlink" title="创建执行器"></a>创建执行器</h2>执行器框架的第一步是创建ThreadPoolExecutor对象。<br>可以使用ThreadPoolExecutor类提供的四个构造器来创建ThreadPoolExecutor对象，也可以使用Executors工厂类来创建。<br>创建Task类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//存储任务的创建时间</span></span><br><span class="line">	<span class="keyword">private</span> Date initDate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存储任务的名称</span></span><br><span class="line">	<span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		initDate = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建时间</span></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Created on: %s\n"</span>, Thread.currentThread().getName(), name, initDate);</span><br><span class="line">		<span class="comment">//开始时间</span></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Started on: %s\n"</span>,Thread.currentThread().getName(),name,<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s: Task %s: Doing a task during %d seconds\n"</span>, Thread.currentThread().getName(), name, duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//结束时间</span></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Finished on: %s\n"</span>, Thread.currentThread().getName(), name, <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建Server类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Server: A new task has arrived\n"</span>);</span><br><span class="line">		executor.execute(task);</span><br><span class="line">		System.out.printf(<span class="string">"Server: Pool Size: %d\n"</span>,executor.getPoolSize());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Active Count: %d\n"</span>,executor.getActiveCount());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Completed Tasks: %d\n"</span>,executor.getCompletedTaskCount());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Server server = <span class="keyword">new</span> Server();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task "</span> + i);</span><br><span class="line">			server.executeTask(task);</span><br><span class="line">		&#125;</span><br><span class="line">		server.endServer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Executors工厂类的newCachedThreadPool()方法创建了一个缓存线程池。<br>这个方法强制转换为ThreadPoolExecutor类型，并拥有所有的方法。<br>如果需要执行新任务，缓存线程池就会创建新线程；如果线程所允许的任务执行完成后并且这个线程可用，那么缓存线程池将会重用这些线程。线程重用的优点是减少了创建线程所花费的时间。然而，新任务固定会依赖线程来执行，因此晕车线程池也有缺点，如果发送过多的任务给执行器，系统的负荷将会过载。</p>
<h5 id="仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool-方法来创建执行器。"><a href="#仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool-方法来创建执行器。" class="headerlink" title="仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool()方法来创建执行器。"></a>仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool()方法来创建执行器。</h5><p>一旦创建了执行器，就可以使用executed()方法来发送Runnable或Callable任务。<br>ThreadPoolExecutor有以下方法</p>
<ul>
<li>getPoolSize() 返回执行器线程池中的实际的线程数</li>
<li>getActiveCount() 返回执行器中正在执行任务的线程数</li>
<li>getCompletedTaskCount() 返回执行器已经完成的任务数</li>
<li>getLargestPoolSize() 返回曾经同时位于线程池中的最大线程数</li>
<li>shutdownNow() 这个方法立即关闭执行器。执行器将不再执行那些正在等待执行的任务。将返回等待执行任务的列表。正在执行的任务还将继续执行，但不等待这些任务完成。</li>
<li>isTerminated() 如果调用了shutdown()或shutdownNow()方法，并且执行器完成了关闭的过程，那么返回true。</li>
<li>isShutdown() 调用了shutdown()返回true</li>
<li>awaitTermination(long timeout,TimeUnit unit) 这个方法将阻塞所调用的线程，直到执行器完成任务或者达到所指定的timeout值。如果想等待任务的结束，而不管任务的持续时间，可以使用一个大的超时时间，比如DAYS。<h5 id="ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。"><a href="#ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。" class="headerlink" title="ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。"></a>ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。</h5><br><br></li>
</ul>
<h2 id="创建固定大小的线程执行器"><a href="#创建固定大小的线程执行器" class="headerlink" title="创建固定大小的线程执行器"></a>创建固定大小的线程执行器</h2><p>Executors提供了一个方法来创建一个固定大小的线程执行器。<br>这个执行器有一个线程数的最大值，如果发送超过这个最大值，执行器将不再创建额外的线程，剩下的任务将被阻塞直到执行器有空闲的线程可用。这可以保证执行器不会给应用程序带来性能不佳的问题。<br>创建Server类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor = (ThreadPoolEexcutor)Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Server: A new task has arrived\n"</span>);</span><br><span class="line">		executor.execute(task);</span><br><span class="line">		System.out.printf(<span class="string">"Server: Pool Size: %d\n"</span>, executor.getPoolSize());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Active Count: %d\n"</span>, executor.getActiveCount());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Task Count: %d\n"</span>,executor.getTaskCount());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Completed Task: %d\n"</span>, executor.getCompletedTaskCount());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endService</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date initDate;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		initDate = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s : Created on: %s\n"</span>, Thread.currentThread().getName(), name, initDate);</span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Started on: %s\n"</span>, Thread.currentThread().getName(), name, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s: Task %s: Doing a task during %d seconds\n"</span>, Thread.currentThread().getName(), name, duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Finished on: %s\n"</span>, Thread.currentThread().getName(), <span class="keyword">new</span> Date(), name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Server server = <span class="keyword">new</span> Server();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task "</span> + i);</span><br><span class="line">			server.executeTask(task);</span><br><span class="line">		&#125;</span><br><span class="line">		server.endServer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Executors工厂类newFiexedThreadPool()创建执行器。<br>Executors工厂类还提供了newSingleThreadExecutors()方法。这是一个创建固定大小线程执行器的极端情况，它将创建一个只有单个线程的执行器。因此，这个执行器只能在同一时间执行一个任务。<br><br>　<br></p>
<h2 id="在执行器中执行任务并返回结果"><a href="#在执行器中执行任务并返回结果" class="headerlink" title="在执行器中执行任务并返回结果"></a>在执行器中执行任务并返回结果</h2><p>执行器框架的优势之一是，可以在运行并发任务并返回结果。<br>Callable：这个接口声明了call()方法。可以在这个方法里实现任务的具体逻辑操作。Callable接口时一个泛型接口，这意味着必须声明call()方法返回的数据类型。<br>Future:这个接口声明了一些方法来获取由Callable对象产生的结果，并管理它们的状态。<br>创建FactorialCalculator类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialCalculator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//存储任务计算的数字</span></span><br><span class="line">	<span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FactorialCalculator</span><span class="params">(Integer number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num, result;</span><br><span class="line">		num = number.intValue();</span><br><span class="line">		result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>((num == <span class="number">0</span> || (num == <span class="number">1</span>))&#123;</span><br><span class="line">			result = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= number; i++)&#123;</span><br><span class="line">				result *= i;</span><br><span class="line">				Thread.sleep(<span class="number">20</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"%s: %d\n"</span>, Thread.currentThread().getName(), result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">//创建一个Future&lt;Integer&gt;类型的列表对象resultList</span></span><br><span class="line">		List&lt;Future&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			Integer number = <span class="keyword">new</span> Integer(random.nextInt(<span class="number">10</span>));</span><br><span class="line">			FactorialCalculator calculator = <span class="keyword">new</span> FactorialCalculator(number);</span><br><span class="line">			Future&lt;Integer&gt; result = executor.submit(calculator);</span><br><span class="line">			resultList.add(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		do&#123;</span><br><span class="line">			<span class="comment">//任务完成的数量</span></span><br><span class="line">			System.out.printf(<span class="string">"Main: Number of Completed Tasks: %d\n"</span>,executor.getCompletedTaskCount());</span><br><span class="line">			<span class="comment">//遍历10个Future对象，通过isDone()输出任务是否完成</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; resultList.size(); i++)&#123;</span><br><span class="line">				Future&lt;Integer&gt; result = resultList.get(i);</span><br><span class="line">				System.out.printf(<span class="string">"Main: Task %d: %s\n"</span>, result.isDone());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Thread.sleep(<span class="number">50</span>);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">while</span>(executor.getCompletedTaskCount()&lt;resultList.size());</span><br><span class="line">		System.out.printf(<span class="string">"Main: Results\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; resultList.size(); i++)&#123;</span><br><span class="line">			Future&lt;Integer&gt; result = resultList.get(i);</span><br><span class="line">			Integer number = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				number = result.get();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"Core: Task %d: %d\n"</span>,i,number);</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现了带有泛型参数Integer类型的Callable接口，因此这个Integer类型将作为在调用call()方法时的返回的类型。<br>通过submit()发送一个Callable对象给执行器去执行，这个submit()方法接受Callable对象作为参数，并返回Future对象。<br>Future对象可以用于以下两个主要目的</p>
<ul>
<li>控制任务的状态：可以取消任务和检查任务是否已完成。为了达到这个目的，可使用isDone()方法来检查任务是否已完成。</li>
<li>通过call()方法获取返回的结果。为了达到这个目的，可使用get()方法。这个方法一直等待直到Callable对象的call()方法执行并返回结果。如果get()方法在等待结果时线程中断了，则抛出一个InterruptedException异常。如果call()方法抛出异常那么get()方法将随之抛出ExecutionException异常。<br>在调用Future对象的get()方法时，如果Future对象所控制的任务并未完成，那么这个方法将一直阻塞到任务完成。还有其他形式的get()</li>
<li>get(long timeout, TimeUnit unit):调用这个方法时，任务的结果并未准备好，则方法等待所指定的timeout时间。如果等待超过了指定的时间而任务的结果还没有准备好，那么这个方法将返回null。<br><br> <br><h2 id="运行多个任务并处理第一个结果"><a href="#运行多个任务并处理第一个结果" class="headerlink" title="运行多个任务并处理第一个结果"></a>运行多个任务并处理第一个结果</h2>并发编程比较常见的一个问题，当采用多个并发任务解决一个问题时，往往只关心这些任务中的第一个结果。<br>比如，对一个数组进行排序有很多算法，可以并发启动所有算法，但是对于一个给定的数字，第一个得到排序结果的算法就是最快的排序算法。<br>创建UserValidator类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserValidator</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserValidator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String name, String password)</span></span>&#123;</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"Validator %s: Validating a user during %d seconds\n"</span>,<span class="keyword">this</span>.name,duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> random.nextBoolean();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建TaskValidator类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskValidator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> UserValidator validator;</span><br><span class="line">	<span class="keyword">private</span> String user;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TaskValidator</span><span class="params">(UserValidator validator,String user, String password)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.validator = validator;</span><br><span class="line">		<span class="keyword">this</span>.user = user;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!validator.validate(user, password))&#123;</span><br><span class="line">			<span class="comment">//如果用户没有通过UserValidator验证，抛出Exception</span></span><br><span class="line">			System.out.printf(<span class="string">"%s: The user has not been found\n"</span>,validator.getName());</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error validating user"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"%s: The user has been found\n"</span>,validator.getName());</span><br><span class="line">		<span class="keyword">return</span> validator.getName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String username = <span class="string">"test"</span>;</span><br><span class="line">		String password = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">		UserValidator ldapValidator = <span class="keyword">new</span> UserValidator(<span class="string">"LDAP"</span>);</span><br><span class="line">		UserValidator dbValidator = <span class="keyword">new</span> UserValidator(<span class="string">"DateBase"</span>);</span><br><span class="line"></span><br><span class="line">		TaskValidator ldapTask = <span class="keyword">new</span> TaskValidator(ldapValidator, username, password);</span><br><span class="line"></span><br><span class="line">		TaskValidator dbTask = <span class="keyword">new</span> TaskValidator(dbValidator, username, password);</span><br><span class="line"></span><br><span class="line">		List&lt;TaskValidator&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		taskList.add(ldapTask);</span><br><span class="line">		taskList.add(dbTask);</span><br><span class="line"></span><br><span class="line">		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">		String result;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			result = executor.invokeAny(taskList);</span><br><span class="line">			System.out.printf(<span class="string">"Main: Result: %s\n"</span>,result);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">		System.out.printf(<span class="string">"Main: End of the Execution\n"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeAny()方法接受一个任务类别，然后运行任务，并返回第一个完成任务并且没有抛出异常的任务的执行结果。<br>UserValidator对象，返回随机的boolean值。<br>每个UserValidator对象被TaskValidator对象使用，TaskValidator对象实现了Callable接口。<br>如果UserValidator类的validate()方法返回false，那么TaskValidator类将抛出Exeception异常，否则，返回true。</p>
<ul>
<li>如果两个任务都返回true值，那么invokeAny()方法的结果就是首先完成任务的名称。</li>
<li>如果第一个任务返回true值，第二个任务抛出异常，那么invokeAny()方法的结果就是第一个任务的名称。</li>
<li>如果第一个任务抛出Exception异常，第二个任务返回true值，那么invokeAny()方法的结果就是第二个任务的名称。</li>
<li>如果两个任务都抛出Exception异常，那么invokeAny()方法将抛出ExecutionException异常。<br>ThreadPoolExecutor类还提供了invokeAny()方法的其他版本，invokeAny(Collection&lt;? extends Callable <t> tasks, long timeout, TimeUnit unit):这个方法执行所有的任务，如果在给定的超时期满之前某个任务已经成功完成（也就是未抛出异常），则返回其结果。</t></li>
</ul>
<p><br> <br></p>
<h2 id="运行多个任务并处理所有结果"><a href="#运行多个任务并处理所有结果" class="headerlink" title="运行多个任务并处理所有结果"></a>运行多个任务并处理所有结果</h2><p>执行器框架（Executor Framework）允许执行并发任务不需要考略线程创建和执行。<br>它还提供了可以用来在先执行器中执行任务的状态和获取任务运行结果的Future类。<br>如想等待任务结束，可以使用如下两种方法</p>
<ul>
<li>如果任务执行结束，那么Future接口的isDone()方法返回false，那么TaskValidator类将抛出Exeception异常，否则，返回true。</li>
<li>在调用shutdown()方法后，ThreadPoolExecutor类的awaitTermination()方法会将线程休眠，直到所有的任务执行结束。<br>创建Result类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Staring\n"</span>, <span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s: Waiting %d seconds for results.\n"</span>, <span class="keyword">this</span>.name,duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			value += (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Result result = <span class="keyword">new</span> Result();</span><br><span class="line">		result.setName(<span class="keyword">this</span>.name);</span><br><span class="line">		result.setValue(value);</span><br><span class="line">		System.out.printf(<span class="string">"%s: Ends\n"</span>, <span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">		List&lt;Task&gt; taskList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task-"</span> + i);</span><br><span class="line">			taskList.add(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;Future&lt;Result&gt;&gt; resultList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			resultList = executor.invokeAll(taskList);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Core: Printing the results\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; resultList.size(); i++)&#123;</span><br><span class="line">			Future&lt;Result&gt; future = resultList.get(i);</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Result result=future.get();</span><br><span class="line">				System.out.printf(<span class="string">"%s: %s\n"</span>,result.getName(),result.getValue());</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException | ExecutionException)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过invokeAll()方法等待所有任务的完成。<br>这个方法接受一个Callable对象列表，并返回一个Future对象列表。<br>在这个列表中，每个任务对应一个Future对象。Future对象列表中的第一个对象控制Callable列表中第一个任务，以此类推。<br>在存储结构的列表声明中，用在Future接口中的泛型参数的数据类型必须与Callable接口的泛型数据类型从相兼容。<br>使用Future对象仅用来获取任务的结果。当所有的任务执行结束时这个方法也执行结束了，如果在返回的Future对象上调用isDone()方法，那么所有的调用将返回true值。<br><br> <br></p>
<h2 id="在执行器中延时执行任务"><a href="#在执行器中延时执行任务" class="headerlink" title="在执行器中延时执行任务"></a>在执行器中延时执行任务</h2><p>想让任务在过一段时间后才被执行或者任务能够被周期性执行，就得用上ScheduleThreadPoolExecutor类。<br>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Starting at : %sn"</span>, name, <span class="keyword">new</span> Date());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ScheduledExecutorService executor = (ScheduledExecutorService)Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Main: Starting at: %sn"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task "</span> + i);</span><br><span class="line">			executor.schedule(task, i + <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			executor.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Core: Ends at : %sn"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ScheduleThreadPoolExecutor执行器，schedule()方法接收如下参数：</p>
<ul>
<li>即将执行的任务</li>
<li>任务执行前所要等待的时间</li>
<li>等待时间的单位，由TimeUnit类的一个常量来指定</li>
</ul>
<p>也可以使用Runnable接口来实现任务，因为ScheduledThreadPoolExecutor类的schedule()方法可以同时接受这两种类型的任务。<br>Java推荐仅在开发定时任务程序时采用ScheduleThreadPoolExecutor类。<br>在调用shutdown()时，可以配置ScheduleThreadPoolExecutor的行为，默认是不论执行器是否结束，待处理的任务仍将被执行。<br>可以童工setExecuteExistingDelayedTasksAfterShutdownPolicy()来改变这个行为，传递false，执行shutdown后，待处理的任务将不会被执行。<br><br> <br></p>
<h2 id="在执行器中周期性执行任务"><a href="#在执行器中周期性执行任务" class="headerlink" title="在执行器中周期性执行任务"></a>在执行器中周期性执行任务</h2><p>通过ScheduleThreadPoolExecutor类来执行周期性的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Executed at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">	System.out.printf(<span class="string">"Main: Starting at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">	Task task = <span class="keyword">new</span> Task(<span class="string">"Task"</span>);</span><br><span class="line">	ScheduledFuture&lt;?&gt; result = executor.scheduleAtFixedRate(task, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Main: Delay: %d\n"</span>, result.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	executor.shutdown();</span><br><span class="line">	System.out.printf(<span class="string">"Main: No More tasks at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.printf(<span class="string">"Main: Finished at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>scheduleAtFixedRate()方法发送任务，这个方法接收4个参数</p>
<ul>
<li>被周期性执行的任务</li>
<li>任务第一次执行后的延时时间</li>
<li>两次执行的时间周期</li>
<li>第2个和第3个参数的时间单位<br>两次执行之间的周期是指任务在两次执行开始时的时间间隔。<br>如果有一个周期性的任务需要5秒钟，但是却让它每3秒执行一次，那么，在任务执行的过程中将会有两个任务实例同时存在。</li>
</ul>
<p>ScheduleThreadPoolExecutor类还提供了其他方法来安排周期性任务的运行。比如，scheduleWithFixedRate()方法。这个方法与scheduledAtFixedRate()方法具有相同的参数，但是略有一些不同需要引起注意。在scheduleAtFixedRate()中，第3个参数表示任务两次执行开始时间的间隔，而在scheduledWithFixedDelay()方法中，第3个参数则是表示任务上一次执行结束的时间与任务下一次开始执行的时间间隔。</p>
<p>也可以配置ScheduleThreadPoolExecutor实心shutdown()方法的行为，默认行为是当调用shutdown()方法后，定时任务就结束了。可以通过ScheduleThreadPoolExecutor类的setContinueExistingPeriodicTasksAfterShutdownPolicy()方法来改变这个行为，传递参数true给这个方法，这样shutdown之后，周期性任务仍将继续执行。</p>
<p><br> <br></p>
<h2 id="在执行器中取消任务"><a href="#在执行器中取消任务" class="headerlink" title="在执行器中取消任务"></a>在执行器中取消任务</h2><p>当线程不再需要时就销毁，Futurn接口的cancel()方法来执行取消操作。<br>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"Task: Test\n"</span>);</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Executing the Task\n"</span>);</span><br><span class="line"></span><br><span class="line">		Future&lt;String&gt; result = executor.submit(task);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Cancelling the Task\n"</span>);</span><br><span class="line">		result.cancel(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Cancelled: %s\n"</span>, result.isCancelled());</span><br><span class="line">		System.out.printf(<span class="string">"Main: Done: %s\n"</span>, result.isDone());</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">		System.out.printf(<span class="string">"Main: The executor has finished\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想取消一个已经发送给执行器的任务，可以使用Future接口的cancel()方法。<br>根据调用cancel()方法时所传递的参数以及任务的状态，这个方法的行为有些不同。</p>
<ul>
<li>如果任务已经完成，或者之前已经被取消，或者由于某种原因而不能被取消，那么方法将返回false并且任务也不能取消。</li>
<li>如果任务在执行器中等待分配Thread对象来执行它，那么任务呗取消，并且不会开始执行。如果任务已经在运行，那么它依赖于调用cancel()方法时所传递的参数。如果传递的参数是true并且任务正在运行，那么任务将被取消。如果传递的参数为false并且任务正在运行，那么任务不会被取消。</li>
</ul>
<p><br> <br></p>
<h2 id="在执行器中控制任务的完成"><a href="#在执行器中控制任务的完成" class="headerlink" title="在执行器中控制任务的完成"></a>在执行器中控制任务的完成</h2><p>FutureTask类提供了一个名为done()的方法，允许在执行器中的任务执行结束之后，还可以执行一些代码。<br>这个方法可以被用来执行一些后期处理操作，比如：产生报表，通过邮件发送结果或释放一些系统资源。<br>当任务执行完成受FutureTask类控制时，这个方法在内部被FutureTask类调用。在任务结果设置好后以及任务的状态已经变为isDone之后，无论任务是否被取消或者正常结束，done()方法才被调用。<br>默认情况下，done()方法的实现为空，即没有任何具体的代码实现。我们可以覆盖FutureTask类并实现done()方法来改变这种行为。<br>创建ExecutableTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	 <span class="keyword">private</span> String name;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">ExecutableTask</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.name = name;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	 	<span class="keyword">try</span>&#123;</span><br><span class="line">	 		Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">	 		System.out.printf(<span class="string">"%s: Waiting %d seconds for results.n"</span>,<span class="keyword">this</span>.name, duration);</span><br><span class="line">	 		TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">	 	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">return</span> <span class="string">"Hello world. I'm "</span> + name;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">return</span> name;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建ResultTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultTask</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ResultTask</span><span class="params">(Callable&lt;String&gt; callable)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(callable);</span><br><span class="line">		<span class="keyword">this</span>.name = ((ExecutableTask) callable).getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isCancelled())&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%s: Has been cancelled\n"</span>,name);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%s: Has finished\n"</span>,name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">		ResultTask resultTasks[] = <span class="keyword">new</span> ResultTask[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			ExecutableTask executableTask = <span class="keyword">new</span> ExecutableTask(<span class="string">"Task "</span> + i);</span><br><span class="line">			resultTasks[i] = <span class="keyword">new</span> ResultTask(executableTask);</span><br><span class="line">			executor.submit(resultTasks[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resultTasks.length; i++)&#123;</span><br><span class="line">			resultTasks[i].cancel(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resultTasks.length; i++)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(!resultTasks[i].isCancelled())&#123;</span><br><span class="line">					System.out.printf(<span class="string">"%s\n"</span>,resultTasks[i].get());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException | ExecutionException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当任务执行结束时，FutureTask类就会调用done()方法。<br>在创建好返回值以及改变任务 状态为isDone之后，FutureTask类就会在内部调用done()方法。<br>虽然我们无法改变任务的结果值，也无法改变任务的状态，但是可以通过任务来关闭系统资源、输出日志信息、发送通知等。</p>
<p><br> <br></p>
<h2 id="在执行器中分离任务的启动与结果的处理"><a href="#在执行器中分离任务的启动与结果的处理" class="headerlink" title="在执行器中分离任务的启动与结果的处理"></a>在执行器中分离任务的启动与结果的处理</h2><p>如果需要在一个对象里发送任务给执行器，然后在另一个对象里处理结果。对于这种情况，Java并发APi提供了CompletionService类。<br>CompletionService类有一个方法用来发送任务给执行器，还有一个方法为下一个已经执行结束的任务获取Future对象。<br>从内部实现的机制来看，CompletionService类使用Executor对象来执行任务。这个行为的优势是可以共享CompletionService对象，并发送任务到执行器，然后其他的对象可以处理任务的结果。<br>第二个方法有一个不足之处，它只能为已经执行结束的任务获取Future对象，因此，这些Future对象只能被用来获取任务的结果。<br>创建ReportGenerator类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportGenerator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String sender;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReportGenerator</span><span class="params">(String sender, String title)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sender = sender;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s_%s: ReportGenerator: Generating a report during %d seconds\n"</span>,<span class="keyword">this</span>.sender, <span class="keyword">this</span>.title, duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		String ret = sender + <span class="string">": "</span> + title;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建ReportProcessor类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CompletionService&lt;String&gt; service;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> end;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReportProcessor</span><span class="params">(CompletionService&lt;String&gt; service)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">		end = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!end)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Future&lt;String&gt; result = service.poll(<span class="number">20</span>, TimeUnit.SECONDS);</span><br><span class="line">				<span class="keyword">if</span>(result)&#123;</span><br><span class="line">					String report = result.get();</span><br><span class="line">					System.out.printf(<span class="string">"ReportReceiver: Report Recived: %s\n"</span>, report);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(<span class="keyword">boolean</span> end)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建ReportRequest类,模拟请求获取报告<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> CompletionService&lt;String&gt; service;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReportRequest</span><span class="params">(String name, CompletionService&lt;String&gt; service)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name; </span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ReportGenerator reportGenerator = <span class="keyword">new</span> ReportGenerator(name, <span class="string">"Report"</span>);</span><br><span class="line">		service.submit(reportGenerator);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">	CompletionService&lt;String&gt; service = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line"></span><br><span class="line">	ReportRequest faceRequest = <span class="keyword">new</span> ReportRequest(<span class="string">"Face"</span>, service);</span><br><span class="line">	ReportRequest onlineRequest = <span class="keyword">new</span> ReportRequest(<span class="string">"Online"</span>, service);</span><br><span class="line">	Thread faceThread = <span class="keyword">new</span> Thread(faceRequest);</span><br><span class="line">	Thread onlineThread = <span class="keyword">new</span> Thread(onlineRequest);</span><br><span class="line"></span><br><span class="line">	ReportProcessor processor = <span class="keyword">new</span> ReportProcessor(service);</span><br><span class="line">	Thread senderThread = <span class="keyword">new</span> Thread(processor);</span><br><span class="line"></span><br><span class="line">	System.out.printf(<span class="string">"Main: Starting the Threads\n"</span>);</span><br><span class="line">	faceThread.start();</span><br><span class="line">	onlineThread.start();</span><br><span class="line">	senderThread.start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Main: Waiting for the report generators.\n"</span>);</span><br><span class="line">		faceThread.join();</span><br><span class="line">		onlineThread.join();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.printf(<span class="string">"Main: Shuting down the executor.\n"</span>);</span><br><span class="line">	executor.shutdown();</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		executor.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	processor.setEnd(<span class="keyword">true</span>);</span><br><span class="line">	System.out.printf(<span class="string">"Main: Ends\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CompletionService类可以执行Callable或Runnable类型的任务，由于Runnable对象不能产生结果，因此CompletionService的基本原则不适用与此。<br>CompletionSe类提供了其他两种方法来获取任务已经完成的Future对象。这些方法如下：</p>
<ul>
<li>poll() 无参数的poll()方法用于检查队列中是否有Future对象。如果队列为空，则立即返回null。否则，它将返回队列中的第一个元素，并移除这个元素。</li>
<li>take()这个方法也没有参数，它检查队列中是否有Future对象。如果队列为空，它将阻塞线程直到队列中有可用的元素。如果队列中有元素，它将返回队列中的第一个元素，并移除这个元素。</li>
</ul>
<p><br> <br></p>
<h2 id="处理在执行器中被拒绝的任务"><a href="#处理在执行器中被拒绝的任务" class="headerlink" title="处理在执行器中被拒绝的任务"></a>处理在执行器中被拒绝的任务</h2><p>当我们想结束执行器的执行时，调用shutdown()方法来表示执行器应当结束。<br>但是，执行器只有等待正在运行的任务或者等待执行的任务结束后，才能真正结束。<br>如果在shutdown()方法与执行器结束之间发送一个任务给执行器，这个任务会被拒绝，因为这个时间段执行器已不再接受任务了。ThreadPoolExecutor类提供了一套机制，当任务呗拒绝时调用这套机制来处理它们。<br>创建RejectedTaskController类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedTaskController</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaskController: The task %s has been rejected\n"</span>,r.toString());</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaskController: %s\n"</span>,executor.toString());</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaskController: Terminating: %s\n"</span>,executor.isTerminating());</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaksController: Terminated: %s\n"</span>,executor.isTerminated());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Task %s : Starting\n"</span>, name);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random()* <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"Task %s: ReportGenerator: Generating a report during %d seconds\n"</span>,name , duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Task %s: Ending\n"</span>, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		RejectedTaskController controller = <span class="keyword">new</span> RejectedTaskController();</span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newCachedThreadPool();</span><br><span class="line">		executor.setRejectedExecutionHandler(controller);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Starting.\n"</span>) ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task"</span> + i);</span><br><span class="line">			executor.submit(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Shuting down the Executor.\n"</span>);</span><br><span class="line">		executor.shutdown(); </span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Sending another Task\n"</span>);</span><br><span class="line">		Task task = <span class="keyword">new</span> Task(<span class="string">"RejectedTask"</span>);</span><br><span class="line">		executor.submit(task);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: End.\n"</span>); </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了处理在执行器中被拒绝的任务，需要创建一个实现RejectedExceptionHandler接口的处理类。这个接口有一个rejectedExecution()方法，其中有两个参数：</p>
<ul>
<li>一个Runnable对象，用来存储被拒绝的任务；</li>
<li>一个Executor对象，用来存储任务被拒绝的执行器。<br>被执行器拒绝的每一个任务都将调用这个方法。需要先调用Executor类的setRejectedExecutionHandle()方法来设置用于被拒绝的任务的处理程序。<br>当执行器接收一个任务并开始执行时，它先检查shutdown()方法是否已经被调用了。如果是，那么执行器就拒绝这个任务。首先，执行器会寻找通过setRejectedExecutionHandler()方法设置的用于被拒绝的任务的处理程序，如果找到一个处理程序，执行器就调用其rejectedExecution()方法：否则就抛出RejectedExecutionExeception异常。这是一个运行时异常，因此并不需要catch语句来对其进行处理。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/05/13/一步一步精通Java多线程4/" data-id="civ9ktzme000fjogf1279ss5x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一步一步精通Java多线程3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/09/一步一步精通Java多线程3/" class="article-date">
  <time datetime="2016-05-09T02:06:07.000Z" itemprop="datePublished">2016-05-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/09/一步一步精通Java多线程3/">Java多线程 0x03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>资源的并发访问控制</li>
<li>资源的多副本的并发访问控制</li>
<li>等待多个并发事件的完成</li>
<li>在集合点的同步</li>
<li>并发阶段任务的运行</li>
<li>并发阶段任务中的阶段切换</li>
<li>并发任务间的数据交换<br><br><br></li>
</ul>
<h2 id="介绍几个更高级的同步机制"><a href="#介绍几个更高级的同步机制" class="headerlink" title="介绍几个更高级的同步机制"></a>介绍几个更高级的同步机制</h2><ul>
<li>信号量(Semaphore)：是一个计数器，用来保护一个或者多个共享资源的访问。</li>
<li>CountDownLatch：Java提供的同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许线程一直等待。</li>
<li>CyclicBarrier：Java同步辅助类，它允许多个线程在某个集合点(common point)处进行互相等待。</li>
<li>Phaser：Java同步辅助类，它把任务分成多个阶段运行，在开始下一个阶段之前，当前阶段内的所有线程都必须执行完成，这是JDK7中的新特性。</li>
<li>Exchanger：Java同步辅助类，它提供两个线程之间的数据交换点。<br><br> <br></li>
</ul>
<h2 id="二进制信号量（Binary-Semaphore）"><a href="#二进制信号量（Binary-Semaphore）" class="headerlink" title="二进制信号量（Binary Semaphore）"></a>二进制信号量（Binary Semaphore）</h2><p>信号量是一个计数器，用来保护一个或者多个共享资源的访问。<br>线程访问一个共享资源，必须先获得信号量。若信号量大于0，信号量减1，然后允许访问这个共享资源；否则，信号量已经是0，此时会把线程置入休眠等待信号量大于0。<br>线程访问完一个共享资源后，信号量必须释放，即将信号量加1。<br>二进制信号量(Binary Semaphore)是一种特殊的信号量，用来保护对唯一共享资源的访问。<br>创建PrintQueue类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>); <span class="comment">//创建二进制信号量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            </span><br><span class="line">            Long duration = (<span class="keyword">long</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">            System.out.printf(<span class="string">"%s: PrintQueue: Printing a Job during %d seconds\n"</span>, Thread.currentThread().getName(),duration);</span><br><span class="line">            TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Job类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s: Going to print a job\n"</span>,Thread.currentThread().getName());</span><br><span class="line">        printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">        System.out.printf(<span class="string">"%s: The document has been printed\n"</span>, Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line"></span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue)，<span class="string">"Thread "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    ｝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>获取信号量的方法acquire()，释放信号量的方法release()。<br>Semaphore类还有其他两种acquire()方法。</p>
<ul>
<li>acquireUninterruptibly()：当信号量为0时，线程会被阻塞，可能会被中断，从而导致acquire()方法抛出InterruptedException异常。而acquireUninterruptibly()方法会忽略线程的中断并且不会抛出任何异常。</li>
<li>tryAcquire()：这个方法试图获取信号量，从而避开线程的阻塞和等待。<br>信号量的公平性，默认都是非公平性的，Semaphore类的构造函数也提供了boolean类型的模式选择。</li>
</ul>
<p><br><br></p>
<h2 id="信号量-Semaphore"><a href="#信号量-Semaphore" class="headerlink" title="信号量(Semaphore)"></a>信号量(Semaphore)</h2><p>信号量可以用来保护一个资源的多个副本，或者被多个线程同时执行的临界区。<br>创建PrintQueue类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Semaphore semaphore;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> freePrinters[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Lock lockPrinters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrintQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">        freePrinters = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">            freePrinters[i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lockPrinters = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="keyword">int</span> assignedPrinter = getPrinter();</span><br><span class="line">            Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s: PrintQueue: Printing a Job in Printer %d during %d seconds\n"</span>,Thread.currentThread().getName(),assignedPrinter,duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line"></span><br><span class="line">            freePrinters[assignedPrinter] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPrinter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ret = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            lockPrinters.lock();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; freePrinters.length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(freePrinters[i])&#123;</span><br><span class="line">                    ret = i;</span><br><span class="line">                    freePrinters[i] = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            lockPrinters.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Job类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Going to print a job\n"</span>,Thread.currentThread().getName());</span><br><span class="line">		printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">		System.out.printf(<span class="string">"%s: The document has been printed\n"</span>,Thread.currentThread().getName());	</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line">        Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">12</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++)&#123;</span><br><span class="line">            thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue), <span class="string">"Thread "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">12</span>; i++)&#123;</span><br><span class="line">            thread[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br></p>
<h2 id="等待多个并发事件的完成"><a href="#等待多个并发事件的完成" class="headerlink" title="等待多个并发事件的完成"></a>等待多个并发事件的完成</h2><p>Java并发API提供了CountDownLatch类，它是一个同步辅助类。<br>在完成一组正在其他线程中执行的操作之前，它允许线程一直等待。<br>这个类使用一个整数进行初始化，这个整数就是线程要等待完成的操作的数目。<br>当一个线程要等待某些操作先执行完时，需要调用await()方法，这个方法让线程进入休眠直到等待的所有操作都完成。<br>当某一个操作完成后，它将调用countDown()方法将CountDownLatch类的内部计数器减1。<br>当计数器变成0的时候，CountDownLatch类将唤醒所有调用await()方法而进入休眠的线程。</p>
<p>创建视频会议类Videoconference<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Videoconference</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch controller;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Videoconference</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        controller = <span class="keyword">new</span> CountDownLatch(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"%s has arrived.\n"</span>,name);</span><br><span class="line">        controller.countDown();</span><br><span class="line">        System.out.printf(<span class="string">"VideoConference: Waiting for %d participants.\n"</span>, controller.getCount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"VideoConference: Initialization: %d participants.\n"</span>, controller.getCount());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            controller.await();</span><br><span class="line">            System.out.printf(<span class="string">"VideoConference: All the participants have come\n"</span>);</span><br><span class="line">            System.out.printf(<span class="string">"VideoConference: Let's start...\n"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建与会者类Participant<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Participant</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Videoconference conference;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Participant</span><span class="params">(Videoconference conference,String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.conference = conference;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        conference.arrive(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Videoconference conference = <span class="keyword">new</span> Videoconference(<span class="number">10</span>);</span><br><span class="line">        Thread threadConference = <span class="keyword">new</span> Thread(conference);</span><br><span class="line">        threadConference.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            Participant p = <span class="keyword">new</span> Participant (conference, <span class="string">"Participant "</span> + i);</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(p);</span><br><span class="line">            t.start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CountDownLatch类有三个基本元素</p>
<ul>
<li>一个初始值，即定义必须等待的先行完成的操作的数目。</li>
<li>await()方法，需要等待其他事件完成的线程调用。</li>
<li>countDown()方法，每个被等待的事件在完成的时候调用。<br>创建CountDownLatch对象时，使用构造其来初始化内部计数器。当countDown()方法被调用后，计数器将减1。当计数器到达0的时候，CountDownLatch对象将唤起所有在await()方法上等待的线程。<br>CountDownLatch对象的内部计数器被初始化之后就不能被再次初始化或者修改。一旦计数器被初始化后，唯一能改变参数值的方法是countDown()方法。当计数器到达0时，所有因调用await()方法而等待的线程立即被唤醒，再执行countDown将不起任何作用。<br>和其他同步方法相比，CountDownLatch机制有下述不同：</li>
<li>CountDownLatch机制不是用来保护共享资源或者临界区的，它是同步执行多个任务的一个或者多个线程。</li>
<li>CountDownLatch只准许进入一次。即一旦CountDownLatch的内部计数器到达0，再调用这个方法将不起作用。<br>CountDownLatch类提供了另一种await()方法，即await(long time, TimeUnit unit)。这个方法被调用后，线程将休眠直到被中断，或者CountDownLatch的内部计数器达到0，或者指定的时间已经过期。<br>第二个参数是TimeUnit类型，TimeUnit类是以下常量的枚举值：DAYS\HOURS\MICROSECONDS\MILLISECONDS\MINUTES\NANOSECONDS\SECONDS。</li>
</ul>
<p><br><br></p>
<h2 id="在集合点的同步"><a href="#在集合点的同步" class="headerlink" title="在集合点的同步"></a>在集合点的同步</h2><p>Java并发API提供了CyclicBarrier类，它也是一个同步辅助类。<br>它允许两个或多个线程在某个点上进行同步。<br>这个类和CountDownLatch类类似，但也有不同之处，使之成为更强大的类。<br>CyclicBarrier类有一个很有意义的改进，可以传入另一个Runnable对象作为初始化参数。<br>当所有线程都到达集合点后，CyclicBarrier将这个Runnable对象作为线程执行。<br>这个特性使得这个类在并行任务上可以媲美分治编程技术（Divide and Conquer Programming Technique）。<br>创建MatrixMock类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixMock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data[][]; <span class="comment">//二维数组data</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//矩阵的行数 每行的长度 寻找的数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MatrixMock</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> length, <span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[size][length];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; size; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">                data[i][j] = random.nexInt(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">if</span>(data[i][j] == number)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"Mock: There are %d ocurrences of number in generated data.\n"</span>, counter, number);</span><br><span class="line">    ｝</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getRow(<span class="keyword">int</span> row)&#123;</span><br><span class="line">        <span class="keyword">if</span>((row &gt;= <span class="number">0</span>) &amp;&amp; (row &lt; data.length))&#123;</span><br><span class="line">            <span class="keyword">return</span> data[row];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果类Results<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Results</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> data[];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Results</span><span class="params">(<span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">int</span> position,<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        data[position] = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getData()&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>查找类Searcher类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> firstRow;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lastRow;</span><br><span class="line">    <span class="keyword">private</span> MatrixMock mock;</span><br><span class="line">    <span class="keyword">private</span> Results results;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CyclicBarrier barrier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Search</span><span class="params">(<span class="keyword">int</span> firstRow,<span class="keyword">int</span> lastRow,MatrixMock mock,Results results, <span class="keyword">int</span> number,CyclicBarrier barrier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstRow = firstRow;</span><br><span class="line">        <span class="keyword">this</span>.lastRow = lastRow;</span><br><span class="line">        <span class="keyword">this</span>.mock = mock;</span><br><span class="line">        <span class="keyword">this</span>.results = results;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> counter;</span><br><span class="line">        System.out.printf(<span class="string">"%s: Processing lines from %d to %d.\n"</span>, Thread.currentThread().getName(),firstRow, lastRow);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = firstRow; i &lt; lastRow; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> row[] = mock.getRow(i);</span><br><span class="line">            counter = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row.length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(row[j] == number)&#123;</span><br><span class="line">                    counter++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            results.setData(i, counter);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"%s: Lines processed.\n"</span>,Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(BrokenBarrierException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Grouper类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Grouper</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Results results;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Grouper</span><span class="params">(Results results)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.results = results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> finalResult = <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"Grouper: Processing results...\n"</span>);</span><br><span class="line">        <span class="keyword">int</span> data[] = results.getData();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> number : data)&#123;</span><br><span class="line">            finalResult += number;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"Grouper: Total result: %d.\n"</span>,finalResult);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> ROWS = <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NUMBERS = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> SEARCH = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> PARTICIPANTS = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> LINES_PARTICIPANT = <span class="number">2000</span>;</span><br><span class="line">        MatrixMock mock = <span class="keyword">new</span> MatrixMock(ROWS, NUMBERS, SEARCH);</span><br><span class="line">        Results results = <span class="keyword">new</span> Results(ROWS);</span><br><span class="line">        Grouper grouper = <span class="keyword">new</span> Grouper(results);</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(PARTICIPANTS, grouper);</span><br><span class="line">        Searcher searchers[] = <span class="keyword">new</span> Searcher[PARTICIPANTS];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PARTICIPANTS; i++)&#123;</span><br><span class="line">            searchers[i] = <span class="keyword">new</span> Searcher(i*LINES_PARTICIPANT, (i*LINES_PARTICIPANT)+LINES_PARTICIPANT, mock, results,<span class="number">5</span>, barrier);</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(searchers[i]);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.printf(<span class="string">"Main: The main thread has finished.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将矩阵分离成5个子集，并且在每个子集中使用线程进行查找，这些线程是查找类Searcher对象。<br>使用CyclicBarrier对象同步5个线程，执行Grouper查找任务处理结果，并且计算最终的结果。<br>CyclicBarrier类有一个内部计数器，可以控制指定数目的几个线程必须都到达集合点。<br>每一个线程到达集合点后就会调用await()方法通知CyclicBarrier对象，CyclicBarrier对象会让这个线程休眠直到其他所有的线程都到达集合点。<br>当所有线程都到达集合点之后，CyclicBarrier对象就唤醒所有的await()方法里等待的线程，同时，还可以以构造器传入的Runnable对象（Grouper对象）创建一个新的线程，以执行其他任务。<br>CyclicBarrier类还提供了getNumberWaiting()方法和getParties()方法，前者将返回在await()上阻塞的线程的数目，后者返回被CyclicBarrier对象同步的任务数。<br>CyclicBarrier类和CountDownLatch类不同，它可以重置回初始状态。<br>CyclicBarrier类提供了reset()方法完成的。当重置发生后，在await()方法中等待的线程将收到一个BrokenBarrierException异常。<br>CyclicBarrier对象有一种特殊的状态即损坏状态（Broken）。当很多线程在await()方法上等待的时候，如果其中一个线程被中断，这个线程将抛出InterruptedException异常，其他的等待线程将抛出BrokenBarrierException异常，于是CyclicBarrier对象就处于损坏状态了。<br>CyclicBarrier类提供了isBroken()方法，如果处于损坏状态就返回true，否则返回false。<br><br> <br></p>
<h2 id="并发阶段任务的运行"><a href="#并发阶段任务的运行" class="headerlink" title="并发阶段任务的运行"></a>并发阶段任务的运行</h2><p>Java API提供了一个更复杂、更强大的同步辅助类，Phaser，它允许执行并发多阶段任务。<br>当有并发任务并且需要分解成几步执行时，这种机制非常适用。<br>Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才允许执行下一步。<br>跟其他同步工具一样，必须对Phaser类中参与同步操作的任务数进行初始化，不同的是，可以动态地增加或者减少任务数。<br>使用Phaser类同步三个并发任务，这三个任务将在三个不同的文件夹及其子文件夹中查找过去24小时内修改过扩展名的.log的文件。<br>这3个任务分成以下三个步骤：</p>
<ul>
<li>在指定的文件夹及其子文件夹中获得扩展名为.log的文件</li>
<li>对第一步的结果进行过滤，删除修改时间超过24小时的文件</li>
<li>将结果打印到控制台<br>在第一步和第二步结束的时候，都会检查所查找的结果列表是不是有元素存在。如果结果列表是空的 ，对应的线程将结束执行，并从phaser中删除。<br>创建FileSearch类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSearch</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String initPath;</span><br><span class="line">	<span class="keyword">private</span> String end;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; results;</span><br><span class="line">	<span class="keyword">private</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileSearch</span><span class="params">(String initPath, String end, Phaser phaser)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.initPath = initPath;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">		<span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">		results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"%s: Starting.\n"</span>, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">		File file = <span class="keyword">new</span> File(initPath);</span><br><span class="line">		<span class="keyword">if</span>(file.isDirectory())&#123;</span><br><span class="line">			directoryProcess(file);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!checkResults())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		filterResults();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>(!checkResults())&#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		showInfo();</span><br><span class="line">		phaser.arriveAndDeregister();</span><br><span class="line">		System.out.printf(<span class="string">"%s: Work completed.\n"</span>,Thread.currentThread().getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.size(); i++)&#123;</span><br><span class="line">			File file = <span class="keyword">new</span> File(results.get(i));</span><br><span class="line">			System.out.printf(<span class="string">"%s: %s\n"</span>, Thread.currentThread().getName(), file.getAbsolutePath());</span><br><span class="line">		&#125;</span><br><span class="line">		phaser.arriveAndAwaitAdvance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//检查结果列表的长度</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkResults</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(results.isEmpty())&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%s: Phase %d: 0 results.\n"</span>, Thread.currentThread().getName(), phaser.getPhase());</span><br><span class="line">			System.out.printf(<span class="string">"%s: Phase %d: End.\n"</span>, Thread.currentThread().getName(), phaser.getPhase());</span><br><span class="line">			phaser.arriveAndDeregister();<span class="comment">//调用Phaser对象当前线程已经结束这个阶段</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%s: Phase %d: %d results.\n"</span>, Thread.currentThread().getName(), phaser.getPhase(), results.size());</span><br><span class="line">			phaser.arriveAndAwaitAdvance();</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//对第一阶段查找到的文件列表进行过滤，将不是过去24小时修改的文件删除</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">filterResults</span><span class="params">()</span></span>&#123;</span><br><span class="line">		List&lt;String&gt; newResults = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		<span class="keyword">long</span> actualDate = <span class="keyword">new</span> Date().getTime();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; results.size(); i++)&#123;</span><br><span class="line">			File file = <span class="keyword">new</span> File(results.get(i));</span><br><span class="line">			<span class="keyword">long</span> fileDate = file.lastModified();</span><br><span class="line">			<span class="keyword">if</span>(actualDate - fileDate &lt;  TimeUnit.MILLISECONDS.convert(<span class="number">1</span>, TimeUnit.DAYS))&#123;</span><br><span class="line">				newResults.add(results.get(i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		results = newResults;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//对每个文件夹递归调用</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">directoryProcess</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">		File list[] = file.listFiles();</span><br><span class="line">		<span class="keyword">if</span>(list != <span class="keyword">null</span>)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++)&#123;</span><br><span class="line">				<span class="keyword">if</span>(list[i].isDirectory())&#123;</span><br><span class="line">					directoryProcess(list[i]);</span><br><span class="line">				&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">					fileProcess(list[i]);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fileProcess</span><span class="params">(File file)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(file.getName().endsWith(end))&#123;</span><br><span class="line">			results.add(file.getAbsolutePath());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">		FileSearch system  = <span class="keyword">new</span> FileSearch(<span class="string">"C:\\XXX"</span>, <span class="string">"log"</span>, phaser);</span><br><span class="line">		FileSearch apps = <span class="keyword">new</span> FileSearch(<span class="string">"C:\\XXXX"</span>, <span class="string">"log"</span>, phaser);</span><br><span class="line">		FileSearch documents = <span class="keyword">new</span> FileSearch(<span class="string">"C:\\XXXXX"</span>,<span class="string">"log"</span>, phaser);</span><br><span class="line"></span><br><span class="line">		Thread systemThread = <span class="keyword">new</span> Thread(system, <span class="string">"System"</span>);</span><br><span class="line">		systemThread.start();</span><br><span class="line"></span><br><span class="line">		Thread appsThread = <span class="keyword">new</span> Thread(apps, <span class="string">"Apps"</span>);</span><br><span class="line">		appsThread.start();</span><br><span class="line"></span><br><span class="line">		Thread documentsThread = <span class="keyword">new</span> Thread(documents, <span class="string">"Documents"</span>);</span><br><span class="line">		documentsThread.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			systemThread.join();</span><br><span class="line">			appsThread.join();</span><br><span class="line">			documentsThread.join();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Terminated: %s\n"</span>, phaser.isTerminated());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开始时候创建Phaser对象，用于在每个阶段结束时对线程同步进行控制。Phaser构造器传入了参与阶段同步的线程的个数。<br>这个数字通知Phaser在唤醒所有休眠线程以进行下一个阶段之前，必须执行arriveAndAwaitAdvance()方法的线程数。<br>在run()方法开头调用arriveAndAwaitAdvanced这个方法可以保障在所有线程创建好之前没有线程开始执行任务。（同一起跑线）<br>在第一阶段和第二阶段结束的时候，检查这个阶段中是不是生成了结果集以及结果集中是不是有元素。<br>在第一阶段,checkResults()方法里调用arriveAndAwaitAdvance()方法。<br>在第二阶段，如果结果集是空的，对应线程没有理由继续执行，所以返回；但必须通知phaser对象参与同步的线程少了一个，调用arriverAndDeregister()方法。<br>在第三阶段结束的时候，在showInfo()方法中调用了phaser对下你给的arriveAndAwaitAdvance()方法，通过这个调用，确保三个线程都已完成。<br>当showInfo()方法执行完成之后，还调用了phaser对象的arriveAndDeregiester()方法，通过这个调用，撤销phaser中线程的注册。<br>一个Phaser对象有两种状态</p>
<ul>
<li>活跃态(Active)：当存在参与同步的线程时，Phaser就是活跃态，并且在每个阶段结束的时候进行同步。</li>
<li>终止态（Termination）：当所有参与同步的线程都取消注册的时候，Phaser就处于终止状态，在这种状态下，Phaser没有任何参与者。<br>当Phaser对象的onAdvance()方法返回true的时候，Phaser对象就处于终止态。<br>当Phaser是终止态是，同步方法arriveAndAwaitAdvance()会立即返回，而且不会做任何同步的操作。<br>Phaser类的一个重大特性就是不必对它的方法进行异常处理。不像其他的同步辅助类，被Phaser类置于休眠的线程不会影响中断事件，也不会抛出InterruptException异常。<br><br><br>Phaser类提供了其他改变Phaser对象的方法</li>
<li>arrive()：这个方法通知phaser对象一个参与者已经完成了当前阶段，但是它不应该等待其他参与者都完成当前阶段。必须小心使用这个方法，因为它不会与其他线程同步。</li>
<li>awaitAdvance(int phaser)：如果传入的阶段参数与当前阶段一直，这个方法会将当前线程置于休眠，直到这个阶段所有参与者都运行完成。如果传入的阶段参数与当前阶段不一致，这个方法将立即返回。</li>
<li>awaitAdvanceInterruptibly(int phaser)：这个方法根awaitAdvance(int phase)一样，不同之处是如果在这个方法中休眠的线程被中断，它将抛出InterruptedException异常。<br><br><br>创建一个Phaser对象时，需要指出有多少个参与者。Phaser类提供两种方法增加注册者的数量。</li>
<li>register()：这个方法将一个新的参与者注册到Phaser中，这个新的参与者将被当成没有执行完本阶段的线程。</li>
<li>bulkRegister(int Parties):这个方法将指定数目的参与者注册到Phaser中，所有这些新的参与者都将被当成没有执行完本阶段的线程。<br><br><br>Phaser类提供了forceTermination()方法来强制phaser进入终止态，这个方法不管phaser中是否存在注册的参与线程。当一个参与线程产生错误时，强制phaser终止时很有意义的。<br>当一个phaser处于终止态时，awaitAdvance()和arriveAndAwaitAdvance()方法立即返回一个负数，而不再是一个正值了。如果知道phaser可能会被终止，就需要验证这些方法的返回值，以确定phaser是不是被终止了。</li>
</ul>
<p><br> <br></p>
<h2 id="并发阶段任务中的阶段切换"><a href="#并发阶段任务中的阶段切换" class="headerlink" title="并发阶段任务中的阶段切换"></a>并发阶段任务中的阶段切换</h2><p>Phaser类提供了onAdvance()方法，它在phaser阶段改变的时候会被自动执行。<br>onAdvance()方法需要两个int型的传入参数：当前的阶段数以及注册的参与者数量。<br>它返回的是boolean值，true表示已经完成执行并进入终止态，false表示phaser还在继续执行。<br>创建MyPhaser类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPhaser</span> <span class="keyword">extends</span> <span class="title">Phaser</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span></span>&#123;</span><br><span class="line">		<span class="keyword">switch</span>(phase)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">				<span class="keyword">return</span> studentsArrived();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">				<span class="keyword">return</span> finishFirstExercise();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">				<span class="keyword">return</span> finishSecondExercise();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">				<span class="keyword">return</span> finishExam();</span><br><span class="line"></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">studentsArrived</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: The exam are going to start. The students are ready.\n"</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: We have %d students.\n"</span>,getRegisteredParties());</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">finishFirstExercise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: All the students has finished the first exercise.\n"</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: It's turn for the second one.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">finishSecondExercise</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: All the students has finished the second exercise.\n"</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: It's turn for the third one.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">finishExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: All the students has finished the exam.\n"</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Phaser: Thank you for your time.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Student类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(Phaser phaser)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.phaser = phaser;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Has arrived to do the exam. %s\n"</span>,Thread.currentThread().getName(),<span class="keyword">new</span> Date());</span><br><span class="line">		phaser.arriveAndAwaitAdvance();</span><br><span class="line">		System.out.printf(<span class="string">"%s: Is going to do the first exercise. %s\n"</span>,Thread.currentThread().getName(),<span class="keyword">new</span> Date());</span><br><span class="line">		doExercise1();</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"%s: Has done the first exercise. %s\n"</span>,Thread.currentThread().getName(),<span class="keyword">new</span> Date());</span><br><span class="line">		phaser.arriveAndAwaitAdvance();</span><br><span class="line">		System.out.printf(<span class="string">"%s: Is going to do the second exercise. %s\n"</span>,Thread.currentThread().getName(),<span class="keyword">new</span> Date());</span><br><span class="line">		doExercise2();</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"%s: Has done the second exercise. %s\n"</span>,Thread.currentThread().getName(),<span class="keyword">new</span> Date());</span><br><span class="line">		phaser.arriveAndAwaitAdvance();</span><br><span class="line">		System.out.printf(<span class="string">"%s: Is going to do the third exercise. %s\n"</span>,Thread.currentThread().getName(),<span class="keyword">new</span> Date());</span><br><span class="line">		doExercise3();</span><br><span class="line">		System.out.printf(<span class="string">"%s: Has finished the exam. %s\n"</span>,Thread.currentThread().getName(),<span class="keyword">new</span> Date());</span><br><span class="line">		phaser.arriveAndAwaitAdvance();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExercise1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Long duration=(<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExercise2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Long duration=(<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doExercise3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Long duration=(<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyPhaser phaser=<span class="keyword">new</span> MyPhaser();</span><br><span class="line"></span><br><span class="line">		Student students[]=<span class="keyword">new</span> Student[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;students.length; i++)&#123;</span><br><span class="line">			students[i]=<span class="keyword">new</span> Student(phaser);</span><br><span class="line">			phaser.register();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Thread threads[]=<span class="keyword">new</span> Thread[students.length];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;students.length; i++) &#123;</span><br><span class="line">			threads[i]=<span class="keyword">new</span> Thread(students[i],<span class="string">"Student "</span>+i);</span><br><span class="line">			threads[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;threads.length; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				threads[i].join();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.printf(<span class="string">"Main: The phaser has finished: %s.\n"</span>,phaser.isTerminated());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>模拟了有三道试题的考试过程。所有的学生做完第一道题才开始做第二道。<br>phaser对象进行阶段切换的时候，在所有arriveAndAwaitAdvance()方法里休眠的线程被唤醒之前，onAdvance()方法将被自动调用。</p>
<p><br> <br></p>
<h2 id="并发任务间的数据交换"><a href="#并发任务间的数据交换" class="headerlink" title="并发任务间的数据交换"></a>并发任务间的数据交换</h2><p>Java并发API提供了Exchanger来实心并发任务之间交换数据。<br>Exchanger类允许在两个线程之间定义同步点（Synchronization Point）。当两个线程都到达同步点时，它们交换数据结构，因此第一个线程的数据结构进入到第二个线程中，同时第二个线程的数据结构进入到第一个线程中。<br>Exchanger类在生产者——消费者中很有用，但Exchanger只能同步两个线程，即一个线程生产者，一个线程消费者。<br>创建Producer类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; buffer;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;List&lt;String&gt;&gt; exchanger;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(List&lt;String&gt; buffer, Exchanger&lt;List&lt;String&gt;&gt; exchanger)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">		<span class="keyword">this</span>.exchanger = exchanger;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cycle = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i  &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"Producer: Cycle %d\n"</span>, cycle);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">				String message = <span class="string">"Event "</span> + ((i*<span class="number">10</span>) + j);</span><br><span class="line">				System.out.printf(<span class="string">"Producer: %s\n"</span>, message);</span><br><span class="line">				buffer.add(message);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				buffer = exchanger.exchange(buffer);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			System.out.printf(<span class="string">"Producer: %d\n"</span>, buffer.size());</span><br><span class="line">			cycle++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Consumer类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; buffer;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Exchanger&lt;List&lt;String&gt;&gt; exchanger;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(List&lt;String&gt; buffer, Exchanger&lt;List&lt;String&gt;&gt; exchanger)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">		<span class="keyword">this</span>.exchanger = exchanger;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">int</span> cycle = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"Consumer: Cycle %d\n"</span>, cycle);</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				buffer = exchanger.exchange(buffer);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"Consumer: %d\n"</span>, buffer.size());</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++)&#123;</span><br><span class="line">				String message = buffer.get(<span class="number">0</span>);</span><br><span class="line">				System.out.printf(<span class="string">"Consumer: %s\n"</span>, message);</span><br><span class="line">				buffer.remove(<span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			cycle++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		List&lt;String&gt; buffer1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		List&lt;String&gt; buffer2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line"></span><br><span class="line">		Exchanger&lt;List&lt;String&gt;&gt; exchanger = <span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		Producer producer = <span class="keyword">new</span> Producer(buffer1, exchanger);</span><br><span class="line">		Consumer consumer = <span class="keyword">new</span> Consumer(buffer2, exchanger);</span><br><span class="line"></span><br><span class="line">		Thread threadProducer = <span class="keyword">new</span> Thread(producer);</span><br><span class="line">		Thread threadConsumer = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line"></span><br><span class="line">		threadProducer.start();</span><br><span class="line">		threadConsumer.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者先创建一个空的缓存列表，然后通过调用Exchanger与生产者同步来获得可以消费的数据。生产者从一个空的缓存列表开始执行，它创建了10个字符串，然后存储在这个缓存中，并且使用exchanger队形与消费者同步。</p>
<p>Exchanger类还提供了另外的exchanger方法，即exchange(V data, long time, TimeUnit unit)方法。<br>V指要交换的数据结构<br>time指定等待的time值<br>TimeUnit可以是DAYS\HOURS\MICROSECONDS\MILLISECONDS\MINUTES\NANOSECONDS\SECONDS</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/05/09/一步一步精通Java多线程3/" data-id="civ9ktzly000ejogfe5lbdqpc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一步一步精通Java多线程2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/04/一步一步精通Java多线程2/" class="article-date">
  <time datetime="2016-05-04T02:48:10.000Z" itemprop="datePublished">2016-05-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/04/一步一步精通Java多线程2/">Java多线程 0x02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>使用synchronized实现同步方法</li>
<li>使用非依赖属性实现同步</li>
<li>在同步代码块中使用条件</li>
<li>使用锁实现同步</li>
<li>使用读写锁同步数据访问</li>
<li>修改锁的公平性</li>
<li>在锁中使用多条件</li>
</ul>
<h2 id="临界区-Critical-Section-是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。"><a href="#临界区-Critical-Section-是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。" class="headerlink" title="临界区(Critical Section)是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。"></a>临界区(Critical Section)是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。</h2><h4 id="Java提供了两种基本的同步机制"><a href="#Java提供了两种基本的同步机制" class="headerlink" title="Java提供了两种基本的同步机制"></a>Java提供了两种基本的同步机制</h4><ul>
<li>synchronized关键字机制</li>
<li>Lock接口及其实现机制<br><br><br></li>
</ul>
<h2 id="使用synchronized实现同步方法"><a href="#使用synchronized实现同步方法" class="headerlink" title="使用synchronized实现同步方法"></a>使用synchronized实现同步方法</h2><p>如果一个对象已用synchronized关键字声明，那么只有一个执行线程被允许访问它。每一个用synchronized关键字声明的静态方法，同时只能被一个执行线程访问，但是其他线程可以访问这个对象的非静态方法。<br>创建Account类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> tmp=balance;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		tmp+=amount;</span><br><span class="line">		balance=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> tmp=balance;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		tmp-=amount;</span><br><span class="line">		balance=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Bank类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Account account;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.account=account;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">			account.subtractAmount(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Company类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Account account;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.account=account;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">			account.addAmount(<span class="number">1000</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Account	account=<span class="keyword">new</span> Account();</span><br><span class="line">		account.setBalance(<span class="number">1000</span>);</span><br><span class="line">		Company	company=<span class="keyword">new</span> Company(account);</span><br><span class="line">		Thread companyThread=<span class="keyword">new</span> Thread(company);</span><br><span class="line">		Bank bank=<span class="keyword">new</span> Bank(account);</span><br><span class="line">		Thread bankThread=<span class="keyword">new</span> Thread(bank);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Account : Initial Balance: %f\n"</span>,account.getBalance());</span><br><span class="line">		</span><br><span class="line">		companyThread.start();</span><br><span class="line">		bankThread.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			companyThread.join();</span><br><span class="line">			bankThread.join();</span><br><span class="line">			System.out.printf(<span class="string">"Account : Final Balance: %f\n"</span>,account.getBalance());</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码演示了错误的场景<br>下面是改进的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> balance;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getBalance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> balance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">double</span> balance)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.balance = balance;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> tmp=balance;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		tmp+=amount;</span><br><span class="line">		balance=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">subtractAmount</span><span class="params">(<span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">double</span> tmp=balance;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Thread.sleep(<span class="number">10</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		tmp-=amount;</span><br><span class="line">		balance=tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>synchronized关键字机制避免了这类错误的方法。<br>一个对象的方法采用synchronized进行声明，只能被一个线程访问。如果线程A正在执行一个同步方法syncMethodA()，线程B要执行这个对象的其他同步方法syncMethodB()，线程B将被阻塞直达线程A访问完。但如果线程B访问的是同一个类的不同对象，那么两个线程都不会被阻塞。<br>synchronized关键字降低了应用的性能，因此只能在并发情景中需要修改共享数据的方法上使用它。<br>可以递归调用被synchronized声明的方法。当线程访问一个对象的同步方法时，它还可以用这个对象的其他的同步方法，也包含正在执行的方法，而不必再次去获取这个方法的访问权。<br>可以通过synchronized关键字来保护代码块（而不是整个方法）的访问。应该利用synchronized关键字：方法的其余部分保持在synchronized代码块之外，以获取更好的性能。临界区(即同一时间只能被一个线程访问的代码块)的访问应该尽可能的短。<br>通常来说，我们使用this关键字来引用正在执行的方法所属的对象。<br><br> <br></p>
<h2 id="使用非依赖属性实现同步"><a href="#使用非依赖属性实现同步" class="headerlink" title="使用非依赖属性实现同步"></a>使用非依赖属性实现同步</h2><p>当使用synchronized来同步代码时，必须把对象引用作为参数传入。 通常情况下，使用this关键字来引用执行方法所属的对象。<br>下面模拟一个场景，有两个屏幕和两个售票处的电影院。<br>创建一个电影院类Cinema<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cinema</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> vacanciesCinmea1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> vacanciesCinmea2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object controlCinema1, controlCinema2; <span class="comment">//两个对象属性</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Cinema</span><span class="params">()</span></span>&#123;</span><br><span class="line">		controlCinema1 = <span class="keyword">new</span> Object();</span><br><span class="line">		controlCinema2 = <span class="keyword">new</span> Object();</span><br><span class="line">		vacanciesCinema1 = <span class="number">20</span>;</span><br><span class="line">		vacanciesCinema2 = <span class="number">20</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个电影院卖票，使用controlCinema1对象控制同步代码块</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sellTicket1</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(controlCineam1)&#123;</span><br><span class="line">			<span class="keyword">if</span>(number &lt; vacanciesCinema1)&#123;</span><br><span class="line">				vacancieCinema1 -= number;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sellTicket2</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(controlCinema2)&#123;</span><br><span class="line">			<span class="keyword">if</span>(number &lt; vacanciesCinema2)&#123;</span><br><span class="line">				vacanciesCinema2 -= number;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//第一个电影院退票，使用controlCinema1控制同步代码块</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">returnTickets1</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(controlCinema1)&#123;</span><br><span class="line">			vacanciesCinema1 += number;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">returnTicket2</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(controlCinema2)&#123;</span><br><span class="line">			vacanciesCinema2 += number;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getVacanciesCinema1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vacanciesCinema1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getVacanciesCinema2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> vacanciesCinema2;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建售票处类TicketOffice<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketOffice1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Cinema cinema;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TicketOffice1</span><span class="params">(Cinema cinema)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cinema = cinema;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cinema.sellTickets1(<span class="number">3</span>);</span><br><span class="line">		cinema.sellTickets1(<span class="number">2</span>);</span><br><span class="line">		cinema.sellTickets1(<span class="number">1</span>);</span><br><span class="line">		cinema.returnTicket1(<span class="number">3</span>);</span><br><span class="line">		cinema.sellTickets1(<span class="number">5</span>);</span><br><span class="line">		cinema.sellTickets2(<span class="number">2</span>);</span><br><span class="line">		cinema.sellTickets2(<span class="number">2</span>);</span><br><span class="line">		cinema.sellTickets2(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketOffice2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Cinema cinema;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TicketOffice2</span><span class="params">(Cinema cinema)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.cinema = cinema;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		cinema.sellTickets2(<span class="number">2</span>);</span><br><span class="line">		cinema.sellTickets2(<span class="number">4</span>);</span><br><span class="line">		cinema.sellTickets1(<span class="number">2</span>);</span><br><span class="line">		cinema.sellTickets1(<span class="number">1</span>);</span><br><span class="line">		cinema.returnTickets2(<span class="number">2</span>);</span><br><span class="line">		cinema.sellTicket1(<span class="number">3</span>);</span><br><span class="line">		cinema.sellTicket2(<span class="number">2</span>);</span><br><span class="line">		cinema.sellTicket1(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Cinema cinema = <span class="keyword">new</span> Cinema();</span><br><span class="line">		</span><br><span class="line">		TicketOffice1 ticketOffice1 = <span class="keyword">new</span> TicketOffice1(cinema);</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(ticketOffice1, <span class="string">"TicketOffice1"</span>);</span><br><span class="line"></span><br><span class="line">		TicketOffice2 ticketOffice2 = <span class="keyword">new</span> TicketOffice2(cinema);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(ticketOffice2, <span class="string">"TicketOffice2"</span>);</span><br><span class="line"></span><br><span class="line">		thread1.start();</span><br><span class="line">		thread2.start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			thread1.join();</span><br><span class="line">			thread2.join();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Room 1 Vacancies: %d\n"</span>, cinema.getVacanciesCinema1());</span><br><span class="line">		System.out.printf(<span class="string">"Room 2 Vacancies: %d\n"</span>, cinema.getVacanciesCinema2());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用synchronized同步代码块，JVM保证同一时间只有一个线程能够访问这个对象的代码保护块(对象，不是类)。<br>上面这个例子，使用一个controlCinema来控制对vacanciesCinema属性的访问，所以同一时刻只有一个线程能够修改这个属性。vacanciesCinema1和vacanciesCinema2有分别的control对象，所以允许同时运行两个线程，一个修改vacanciesCinema1，另一个修改vacanciesCinema2。<br><br> <br></p>
<h2 id="在同步代码中使用条件"><a href="#在同步代码中使用条件" class="headerlink" title="在同步代码中使用条件"></a>在同步代码中使用条件</h2><p>在并发编程中一个典型的问题是生产者-消费者问题。<br>Java在Object类中提供了wait()、notify()和notifyAll()方法。 线程可以在同步代码块中调用wait()方法。如果在同步代码块外调用wait()，JVM将抛出IllegalMonitorStateException异常。<br>当一个线程调用wait()方法后，JVM将这个线程置入休眠，并释放控制这个同步代码块的对象，同时允许其他线程执行这个对象控制的其他同步代码块。 为了唤醒这个线程，必须在这个对象控制的某个同步代码块中调用notify()或者notifyAll()方法。<br>下面结合例子学习下生产者-消费者问题。<br>创建EventStorage类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventStorage</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize; </span><br><span class="line">	<span class="keyword">private</span> List&lt;Data&gt; storage;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EventStorage</span><span class="params">()</span></span>&#123;</span><br><span class="line">		maxSize = <span class="number">10</span>;</span><br><span class="line">		storage = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(storage.size() == maxSize)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		storage.add(<span class="keyword">new</span> Date());</span><br><span class="line">		System.out.printf(<span class="string">"Set: %d"</span>, storage.size());</span><br><span class="line">		notify();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(storage.size() == <span class="number">0</span>&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Get : %d: %s"</span>, storage.size(), ((LinkedList&lt;?&gt;) storage).poll());</span><br><span class="line">		notify();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建生产者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> EventStorage storage;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(EventStorage storage)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.storage = storage;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			storage.set();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建消费者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> EventStorage storage;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(EventStorage storage)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.storage = storage;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i  &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			storage.get();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		EventStorage storage = <span class="keyword">new</span> EventStorage();</span><br><span class="line"></span><br><span class="line">		Producer producer = <span class="keyword">new</span> Producer(storage);</span><br><span class="line">		Thread thread1 = <span class="keyword">new</span> Thread(producer);</span><br><span class="line"></span><br><span class="line">		Consumer consumer = <span class="keyword">new</span> Consumer(storage);</span><br><span class="line">		Thread thread2 = <span class="keyword">new</span> Thread(consumer);</span><br><span class="line"></span><br><span class="line">		thread2.start();</span><br><span class="line">		thread1.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有了wait()和notify()机制，两个线程之间就有了通信。<br>其次，当其他线程调用notifyAll()方法时，挂起的线程将被唤醒并且再次检查条件。但notifyAll()并不保证哪个线程会被唤醒。</p>
<p><br> <br></p>
<h2 id="使用锁实现同步"><a href="#使用锁实现同步" class="headerlink" title="使用锁实现同步"></a>使用锁实现同步</h2><p>Java提供了同步代码块的另一种机制，它比synchronized更强大也更灵活。<br>这种机制基于Lock接口及其实现类（例如ReentrantLock），提供了更多的好处。</p>
<ul>
<li>支持更灵活的同步代码块结构。使用synchronized只能在同一个synchronized块结构中获取和释放控制。Lock接口允许实现更复杂的临界区结构</li>
<li>相比synchronized关键字，Lock接口提供了更多的功能。其中一个新功能是tryLock()方法的实现。这个方法试图获取锁，如果锁一杯其他线程获取，它将返回false并继续往下执行代码。使用锁的tryLock()方法， 通过返回值将得知是否有其他线程正在使用这个锁保护的代码块。</li>
<li>Lock接口允许分离读和写操作，允许多个读线程和只有一个写线程。</li>
<li>相比synchronized，Lock接口具有更好的性能。<br>好了，开始学习下ReentrantLock——Lock接口的实现类。<br>创建PrintQueue类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintQueue</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Lock queueLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printJob</span><span class="params">(Object document)</span></span>&#123;</span><br><span class="line">		queueLock.lock();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s : PrintQueue: Printing a Job during %d seconds\n"</span>, Thread.currentThread().getName(), (duration/<span class="number">1000</span>));</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			queueLock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建Job类并实现Runnable接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PrintQueue printQueue;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(PrintQueue printQueue)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.printQueue = printQueue;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Going to print a document\n"</span>,Thread.currentThread().getName());</span><br><span class="line">		printQueue.printJob(<span class="keyword">new</span> Object());</span><br><span class="line">		System.out.printf(<span class="string">"%s: The document has been printed\n"</span>,Thread.currentThread().getName());	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		PrintQueue printQueue = <span class="keyword">new</span> PrintQueue();</span><br><span class="line"></span><br><span class="line">		Thread thread[] = <span class="keyword">new</span> Thread[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			thread[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Job(printQueue), <span class="string">"Thread "</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			thread[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这个临界区的开始，必须通过lock()方法获取对锁的控制。当线程A访问这个方法时，如果没有其他线程获取这个锁的控制，lock()方法将让线程A获取锁并且允许它立即执行临界区代码。否则，如果其他线程B正在执行这个锁保护的临界区代码，lock()方法将让线程A休眠直到线程B执行完临界区的代码。<br>在线程离开临界区的时候，必须使用unlock()方法来释放它持有的锁，以让其他线程来访问临界区。如果离开临界区的时候没有调用unlock()方法，其他线程将永久地等待，从而导致死锁(Deadlock)。<br>如果临界区使用了try-catch块，不要忘记将unlock()放入finally里。<br>Lock接口还提供了额另一个方法来获取锁，即tryLock()，跟lock()方法最大的不同是：线程使用tryLock()不能获取锁，tryLock()会立即返回，它不会讲线程置入休眠。tryLock()方法返回一个布尔值，true表示线程获取了锁，false表示没有获取锁。<br>ReentrantLock类也允许使用递归调用。如果一个线程获取了锁并且进行了递归调用，它将继续持有这个锁，因此调用lock()方法后也将立即返回，并且线程将继续执行递归调用。<br><br> <br></p>
<h2 id="使用读写锁实现同步数据访问"><a href="#使用读写锁实现同步数据访问" class="headerlink" title="使用读写锁实现同步数据访问"></a>使用读写锁实现同步数据访问</h2><p>锁机制最大的改进之一就是ReadWriteLock接口和它的唯一实现类ReentrantReadWriteLock。<br>这个类有两个锁，一个是读操作锁，另一是写操作锁。<br>使用读操作锁可以允许多个线程同时访问，但是写操作锁只允许一个线程进行。<br>创建一PricesInfo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PricesInfo</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price1;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">double</span> price2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ReadWriteLock lock;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PricesInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">		price1 = <span class="number">1.0</span>;</span><br><span class="line">		price2 = <span class="number">2.0</span>;</span><br><span class="line">		lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice1</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.readLock().lock();</span><br><span class="line">		<span class="keyword">double</span> value = price1;</span><br><span class="line">		lock.readLock().unlock();</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice2</span><span class="params">()</span></span>&#123;</span><br><span class="line">		lock.readLock().lock();</span><br><span class="line">		<span class="keyword">double</span> value = price2;</span><br><span class="line">		lock.readLock().unlock();</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrices</span><span class="params">(<span class="keyword">double</span> price1, <span class="keyword">double</span> price2)</span></span>&#123;</span><br><span class="line">		lock.writeLock().lock();</span><br><span class="line">		<span class="keyword">this</span>.price1 = price1;</span><br><span class="line">		<span class="keyword">this</span>.price2 = price2;</span><br><span class="line">		lock.writeLock().unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Reader<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PricesInfo pricesInfo;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(PricesInfo pricesInfo)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.pricesInfo = pricesInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%s: Price 1: %f\n"</span>,Thread.currentThread().getName(),pricesInfo.getPrice1());</span><br><span class="line">			System.out.printf(<span class="string">"%s: Price 2: %f\n"</span>,Thread.currentThread().getName(),pricesInfo.getPrice2());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Writer类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> PricesInfo pricesInfo;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Writer</span><span class="params">(PricesInfo pricesInfo)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.pricesInfo = pricesInfo;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i++)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"Writer: Attempt to modify the prices.\n"</span>);</span><br><span class="line">			pricesInfo.setPrices(Math.random()*<span class="number">10</span>, Math.random()*<span class="number">8</span>);</span><br><span class="line">			System.out.printf(<span class="string">"Writer: Prices have been modified.\n"</span>);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep(<span class="number">2</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;			</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		PricesInfo pricesInfo = <span class="keyword">new</span> PricesInfo();</span><br><span class="line"></span><br><span class="line">		Reader readers[] = <span class="keyword">new</span> Reader[<span class="number">5</span>];</span><br><span class="line">		Thread threadsReader[] = <span class="keyword">new</span> Thread[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt;  <span class="number">5</span>; i++)&#123;</span><br><span class="line">			readers[i] = <span class="keyword">new</span> Reader(pricesInfo);</span><br><span class="line">			threadsReader[i] = <span class="keyword">new</span> Thread(readers[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Writer writer = <span class="keyword">new</span> Writer(pricesInfo);</span><br><span class="line">		Thread threadWriter = <span class="keyword">new</span> Thread(writer);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			threadsReader[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">		threadWriter.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br> <br></p>
<h2 id="修改锁的公平性"><a href="#修改锁的公平性" class="headerlink" title="修改锁的公平性"></a>修改锁的公平性</h2><p>ReentrantLock和ReentrantReadWriteLock类的构造器都含有一个布尔参数fair，它允许控制这两个类的行为。<br>默认fair是false，它称为非公平模式（Non-Fair Mode)。<br>在非公平模式下，当有很多线程在等待锁时，锁将选择它们中的一个来访问临界区，这个选择是灭有任何约束的。<br>fair是true，公平模式(Fair Mode)，当有很多线程在等待锁时，锁将选择它们中的一个来访问临界区，而且选择的是等待时间最长的。<br>这两种模式只适合于lock()和unlock方法。而Lock接口的tryLcok()方法没有将线程置于休眠，fair属性并不影响这个方法。</p>
<h2 id="在锁中使用多条件-Multiple-Condition"><a href="#在锁中使用多条件-Multiple-Condition" class="headerlink" title="在锁中使用多条件(Multiple Condition)"></a>在锁中使用多条件(Multiple Condition)</h2><p>一个锁可能关联一个或者多个条件，这些条件通过Condition接口声明。目的是允许线程获取锁并且查看等待的某一个条件是否满足，如果不满足就挂起直到某个线程唤醒它们。<br>Condition接口提供了挂起线程和唤起线程的机制。<br>还是以生产者消费者为例<br>创建FileMock类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileMock</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String content[] ;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FileMock</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">		content = <span class="keyword">new</span> String[size];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; size; i++)&#123;</span><br><span class="line">			StringBuilder buffer = <span class="keyword">new</span> StringBuilder(length);</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)&#123;</span><br><span class="line">				<span class="keyword">int</span> indict = (<span class="keyword">int</span>)Math.random()*<span class="number">255</span>;</span><br><span class="line">				buffer.append((<span class="keyword">char</span>) indice);</span><br><span class="line">			&#125;</span><br><span class="line">			content[i] = buffer.toString();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreLines</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> index &lt; content.length;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getLine</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.hasMoreLines())&#123;</span><br><span class="line">			System.out.println(<span class="string">"Mock: "</span> + (content.length-index));</span><br><span class="line">			<span class="keyword">return</span> content[index++];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现数据缓冲类Buffer，它将被生产者和消费者共享。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buffer</span></span>&#123;</span><br><span class="line">	<span class="comment">//存放共享数据</span></span><br><span class="line">	<span class="keyword">private</span> LinkedList&lt;String&gt; buffer; </span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSize;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> Condition lines;</span><br><span class="line">	<span class="keyword">private</span> Condition space;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//缓冲区是否还有数据</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> pendingLines;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Buffer</span><span class="params">(<span class="keyword">int</span> maxSize)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.maxSize = maxSize;</span><br><span class="line">		buffer = <span class="keyword">new</span> LinkedList();</span><br><span class="line">		lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">		lines = lock.newCondition();</span><br><span class="line">		space = lock.newCondition();</span><br><span class="line">		pendingLines = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(String line)</span></span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="comment">//缓冲区是否还有空位</span></span><br><span class="line">				<span class="keyword">while</span>(buffer.size() == maxSize)&#123;</span><br><span class="line">					space.await(); <span class="comment">//当space的signal()或singalAll()时会被唤醒</span></span><br><span class="line">				&#125;</span><br><span class="line">				buffer.offer(line);</span><br><span class="line">				System.out.printf(<span class="string">"%s: Inserted Line: %d\n"</span>, Thread.currentThread()</span><br><span class="line">					.getName(), buffer.size());</span><br><span class="line">				lines.signalAll(); <span class="comment">//唤醒等待缓冲区中有数据的线程</span></span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">				lock.unlock();</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">		String line = <span class="keyword">null</span>;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="keyword">while</span>((buffer.size() == <span class="number">0</span>) &amp;&amp; (hasPendingLines()))&#123;</span><br><span class="line">				lines.await(); <span class="comment">//缓存区是不是有数据行</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(hasPendingLines())&#123;</span><br><span class="line">				line = buffer.poll();</span><br><span class="line">				System.out.printf(<span class="string">"%s: Line Readed: %d\n"</span>,Thread.currentThread().getName(),buffer.size());</span><br><span class="line">				space.signalAll();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> line;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPendingLines</span><span class="params">(<span class="keyword">boolean</span> pendingLines)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.pendingLines = pendingLines;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPendingLines</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pendingLines || buffer.size() &gt; <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>消费者类Consumer<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Buffer buffer;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Buffer buffer)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.buffer = buffer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(buffer.hasPendingLines())&#123;</span><br><span class="line">			String line = buffer.get();</span><br><span class="line">			processLine(line);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processLine</span><span class="params">(String line)</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Random random = <span class="keyword">new</span> Random();</span><br><span class="line">			Thread.sleep(random.nextInt(<span class="number">100</span>));</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>生成者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> FileMock mock;</span><br><span class="line">	<span class="keyword">private</span> Buffer buffer;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(FileMock mock, Buffer buffer)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mock = mock;</span><br><span class="line">		<span class="keyword">this</span>.buffer = buffer;	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		buffer.setPendingLines(<span class="keyword">true</span>);</span><br><span class="line">		<span class="keyword">while</span>(mock.hasMoreLines())&#123;</span><br><span class="line">			String line = mock.getLine();</span><br><span class="line">			buffer.insert(line);</span><br><span class="line">		&#125;</span><br><span class="line">		buffer.setPendingLines(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		FileMock mock = <span class="keyword">new</span> FileMock(<span class="number">101</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">		Buffer buffer = <span class="keyword">new</span> Buffer(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">		Producer producer = <span class="keyword">new</span> Producer(mock, buffer);</span><br><span class="line">		Thread threadProducer = <span class="keyword">new</span> Thread(producer, <span class="string">"Producer"</span>);</span><br><span class="line"></span><br><span class="line">		Consumer consumers[] = <span class="keyword">new</span> Consumer[<span class="number">3</span>];</span><br><span class="line">		Thread threadConsumers[] = <span class="keyword">new</span> Thread[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			consumers[i] = <span class="keyword">new</span> Consumer(buffer);</span><br><span class="line">			threadConsumers[i] = <span class="keyword">new</span> Thread(consummers[i], <span class="string">"Consumser "</span> + i);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		threadProducer.start();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			threadConsumers[i].start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>与锁绑定的所有条件对象都是通过Lock接口声明的newCondition()方法创建的。<br>在使用条件的时候，必须获取这个条件绑定的锁。<br>当线程调用条件的await()方法时，它将自动释放这个条件绑定的锁，其他某个线程才可以获取这个锁并且执行相同的操作，或者执行这个锁保护的另一个临界区代码。<br>当一个线程调用了条件对象的signal()或者signalAll()方法后，一个或者多个在该条件上挂起的线程将被唤醒，但这并不能保证让它们挂起的条件已经满足，所以必须在while循环中调用await()，在条件成立之前不能离开这个循环，如果条件不成立，将再次调用await()。<br>因调用await()方法的线程可能会被中断，所以必须处理InterruptException异常。<br><br><br>Condition接口还提供了await()方法的其他形式<br>await(long time, TimeUnit unit):直到发生以下情况之一前，线程将一直处于休眠状态</p>
<ul>
<li>其他某个线程中断当前线程</li>
<li>其他某个线程调用了将当前线程挂起的条件的signal()或signalAll()方法。</li>
<li>指定的等待时间已经过去。</li>
<li>通过TimeUnit类的常量DAYS HOURS MiCROSECONDS MILLISECONDS MINUTES ANOSECONDS SECONDS指定的等待时间已经过去<br><br><br>awaitUniterruptibly():它是不能中断的。这个线程将休眠知道其他某个线程调用了将它挂起的条件的signal()或signalAll()方法。<br>awaitUnitl(Date date):直到发生以下情况之一之前，线程将一直处于休眠状态</li>
<li>其他某个线程中断当前线程</li>
<li>其他某个线程调用了将它挂起的条件的signal()或signalAll()</li>
<li>指定的最后期限到了</li>
</ul>
<p>也可以将条件与读写锁ReadLock和WriteLock一起用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/05/04/一步一步精通Java多线程2/" data-id="civ9ktzl30008jogf94516rd9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-一步一步精通Java多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/22/一步一步精通Java多线程/" class="article-date">
  <time datetime="2016-04-22T04:31:15.000Z" itemprop="datePublished">2016-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/22/一步一步精通Java多线程/">Java多线程 0x01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>线程的创建和运行</li>
<li>线程信息的获取和设置</li>
<li>线程的中断</li>
<li>线程中断的控制</li>
<li>线程的休眠和恢复</li>
<li>等待线程的终止</li>
<li>守护线程的创建和运行</li>
<li>线程中不可控异常的处理</li>
<li>线程局部变量的使用</li>
<li>线程的分组</li>
<li>线程组中不可控异常的处理</li>
<li>使用工厂类创建线程<br><br><br><br></li>
</ul>
<h2 id="不得不讲的并发与并行"><a href="#不得不讲的并发与并行" class="headerlink" title="不得不讲的并发与并行"></a>不得不讲的并发与并行</h2><p>所有的并发处理都有排队等候，唤醒，执行至少三个这样的步骤.所以并发肯定是宏观概念，在微观上他们都是序列被处理的，只不过资源不会在某一个上被阻塞(一般是通过时间片轮转)，所以在宏观上看多个几乎同时到达的请求同时在被处理。<br>并发的实质是一个物理CPU(也可以多个物理CPU) 在若干道程序之间多路复用，并发性是对有限物理资源强制行使多用户共享以提高效率。<br>并行性指两个或两个以上事件或活动在同一时刻发生。在多道程序环境下，并行性使多个程序同一时刻可在不同CPU上同时执行。<br><br><br><br></p>
<h2 id="线程的创建和运行"><a href="#线程的创建和运行" class="headerlink" title="线程的创建和运行"></a>线程的创建和运行</h2><p>Java提供了两种方式来创建线程：<br>1)继承Thread类，并覆盖run()方法<br>2）创建一个是实现Runnable接口的类。<br>下面以第二种方式创建10个简单的线程，每个线程完成计算和打印乘以1-10后的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.number = number;</span><br><span class="line">   &#125; </span><br><span class="line">   </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">           System.out.printf(<span class="string">"%s: %d * %d = %d\n"</span>,  Thread.currentThread().getName(), number, i, i*number);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着编写一个主类，进行测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">           Calculator calculator = <span class="keyword">new</span> Calculator(i);</span><br><span class="line">           Thread thread = <span class="keyword">new</span> Thread(calculator);</span><br><span class="line">           thread.start();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单说明下，对一个实现了Runnable接口的类来说，创建Thread对象并不会创建一个新的执行线程，同样，调用它的run()方法，也不会创建一个新的执行线程。只有当Thread调用start()方法时，才会创建一个新的执行线程来调用run()方法。<br>当一个程序的所有线程都运行完成时，更明确的说，当所有非守护线程都运行完成的时候，这个Java程序将宣告结束。<br>如果main线程结束了，而其余的线程仍将继续执行它们的任务，直到运行结束。但如果某一个线程调用了System.exit()指令来结束程序的执行，则所有的线程都将结束。<br><br><br></p>
<h2 id="线程信息的获取和设置"><a href="#线程信息的获取和设置" class="headerlink" title="线程信息的获取和设置"></a>线程信息的获取和设置</h2><p>Thread类有一些保存信息的属性，这些属性可以用来标识线程，如显示线程的状态、控制线程的优先级。<br>ID：保存了线程的唯一标识。<br>Name：保存了线程的名称。<br>Priority：保存了线程的优先级。从1到10，由低优先级到高优先级。<br>Status：保存了线程的状态。在Java中，有6种状态，new \ runnable \ blocked \ waiting \ timewaiting \ terminated。<br>下面我们来打印下线程的这些标识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Calculator</span><span class="params">(<span class="keyword">int</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"%s: %d * %d = %d\n"</span>, Thread.currentThread().getName(), number, i, i*number);  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Minimum Priority:%s\n"</span>, Thread.MIN_PRIORITY);</span><br><span class="line">        System.out.println(<span class="string">"Normal Priority:%s\n"</span>, Thread.NORM_PRIORITY);</span><br><span class="line">        System.out.println(<span class="string">"Maximum Priority:%s\n"</span>, Thread.MAX_PRIORITY);</span><br><span class="line">        </span><br><span class="line">        Thread threads[] = <span class="keyword">new</span> Thread&#123;<span class="number">10</span>];</span><br><span class="line">        Thread.State status[] = <span class="keyword">new</span> Thread.State[<span class="number">10</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Calculator(i));</span><br><span class="line">            <span class="keyword">if</span>((i%<span class="number">2</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                threads[i].setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                threads[i].setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            threads[i].setName(<span class="string">"Thread "</span> +i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//创建PrintWriter对象，用来把线程的状态演变写入到文件中</span></span><br><span class="line">        <span class="comment">//try()&#123;&#125;catch&#123;&#125; 这个是Jdk7的新语法，可以看到这样代码简洁很多，不用在finally&#123;&#125;里关闭流。</span></span><br><span class="line">        <span class="keyword">try</span>( FileWriter file = <span class="keyword">new</span> FileWriter(<span class="string">".\\data\\log.txt"</span>); </span><br><span class="line">             PrintWriter pw = <span class="keyword">new</span> PrintWriter(file);)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                pw.println(<span class="string">"Main: Status of Thread "</span> + i + <span class="string">" : "</span> + threads[i].getState());</span><br><span class="line">                status[i] = threads[i].getState();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                threads[i].start();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">boolean</span> finish = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">while</span>(!finish)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(threads[i].getState() != status[i])&#123;</span><br><span class="line">                        writeThreadInfo(pw, threads[i], status[i]);</span><br><span class="line">                        status[i] = threads[i].getState();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                finish = <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">                    finish = finish &amp;&amp; (threads[i].getState() == State.TERMINATED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeThreadInfo</span><span class="params">(PrintWriter pw, Thread thread, State state)</span></span>&#123;</span><br><span class="line">        pw.printf(<span class="string">"Main : Id %d - %s\n"</span>, thread.getId(), thread.getName());</span><br><span class="line">        pw.printf(<span class="string">"Main : Priority: %d\n"</span>, thread.getPriority());</span><br><span class="line">        pw.printf(<span class="string">"Main : Old state: %s\n"</span>, state);</span><br><span class="line">        pw.printf(<span class="string">"Main : New state: %s\n"</span>, thread.getState());</span><br><span class="line">        pw.printf(<span class="string">"Main : ************************************\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样每个线程的状态演变都记录在log.txt里。<br>Thread类的属性存储了线程的所有信息，JVM使用线程的Priority来决定某一时刻由哪个线程来使用CPU，并根据线程的情景为它们设置实际的状态。<br>如果Thread类没有取名字，JVM会自动分配一个名字给它，如Thread-XX。<br>Thread的ID和状态是只读的，不能自己set。另外，setPriority()方法的值必须是1~10之内，超过这个访问会报IllegalArgumentException异常。<br><br><br><br></p>
<h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><p>前面提到过单个线程结束并不会使进程结束，只有当所有的线程都结束了，这个进程才会结束。中途结束进程可以调用System.exit()，那么中途结束线程呢？Java也提供了中断机制。这种机制要求线程检查它是否被中断了，然后决定是不是影响这个中断请求。换句话说，线程是允许忽略中断请求并继续运行的。</p>
<p>接下来,还是以代码来说明<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> number = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPrime(number))&#123;</span><br><span class="line">                System.out.println(<span class="string">"Number %d is Prime\n"</span>, number);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isInterrupted())&#123;</span><br><span class="line">                System.out.println(<span class="string">"The Prime Generator has been Interrupted\n"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            number++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">    *是否是质数</span><br><span class="line">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">long</span> number)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(number &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">2</span>; i &lt; number; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((number % i )==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Thread task = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">        task.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        task.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Thread类有一个表明线程被中断与否的属性，它存放的是布尔值。线程的interrupt()方法被调用时，这个属性就会被设置为true。isInterrupted()方法只是返回这个属性的值。<br><br><br><br></p>
<h2 id="线程中断的控制"><a href="#线程中断的控制" class="headerlink" title="线程中断的控制"></a>线程中断的控制</h2><p>已经学会中断线程，也学会了在线程对象中去控制这个中断。在实际编码中，如果线程实现了复杂的算法并且分布在几个方法中，或者线程里有递归调用等，我们就得使用一个更好的机制来控制线程的中断。Java提供了InterruptedException异常。当检查到线程中断时，就抛出这个异常，然后在run()中捕获并处理这个异常。<br>主程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FileSearch searcher = <span class="keyword">new</span> FileSearch(<span class="string">"C:\\"</span>, <span class="string">"autoexec.bat"</span>);</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(searcher);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样不管递归调用多少次，只要抛出InterruptedException，就结束线程，释放资源。<br><br><br><br></p>
<h2 id="线程的休眠和恢复"><a href="#线程的休眠和恢复" class="headerlink" title="线程的休眠和恢复"></a>线程的休眠和恢复</h2><p>线程的休眠可以通过调用sleep()方法来实现。sleep()方法接受整型数值作为参数，以表明线程挂起执行的毫秒数。<br>sleep()方法的另一种使用方式是通过TimeUnit枚举类进行调用。这个方法也使用Thread类的sleep()方法来使当前线程休眠，但是它接受的参数单位是秒，最终会被转化成毫秒。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileClock</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"%s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                System.out.println(<span class="string">"The FileClock has been interrupted"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FileClock clock = FileClock();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(clock);</span><br><span class="line">        </span><br><span class="line">        thread.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果休眠中线程被中断，该方法就会立即抛出InterruptedException异常，而不需要等待到线程休眠时间结束<br><br><br><br></p>
<h2 id="等待线程的终止"><a href="#等待线程的终止" class="headerlink" title="等待线程的终止"></a>等待线程的终止</h2><p>有时候，我们必须等待某个线程的终止，这个时候可以使用Thread类的join()方法。当一个线程对象的join()方法被调用时，调用它的线程将被挂起，直到这个线程对象完成它的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourcesLoader</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;    </span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Begining data sources loading: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">4</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Data sources loading has finished: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkConnectionsLoader</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Begining network connections loading:%s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">6</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"Network connections loading has finished: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DataSourcesLoader dsLoader = <span class="keyword">new</span> DataSourcesLoader();</span><br><span class="line">        Thread thread1 = <span class="keyword">new</span> Thread(dsLoader, <span class="string">"DataSourceThread"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        </span><br><span class="line">        NetworkConnectionsLoader ncLoader = <span class="keyword">new</span> NetworkConnectionsLoader();</span><br><span class="line">        Thread thread2 = <span class="keyword">new</span> Thread(ncLoader, <span class="string">"NetworkConnectionLoader"</span>);</span><br><span class="line">        thread2.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            thread1.join();</span><br><span class="line">            thread2.join();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"Main: Configuration has been loader: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行发现，只有当DataSourcesLoader线程运行结束，NetworkConnectionsLoader线程也运行结束的时候，主线程对象才会继续运行并且打印出最终的信息。<br>另外，java还提供了另外两个形式的join()方法：join(long milliseconds) join(long milliseconds, long nanos)<br>这两种形式的join返回比join()方法多一个条件，就是指定的时间到时，线程也将继续执行。<br><br><br><br></p>
<h2 id="守护线程的创建和运行"><a href="#守护线程的创建和运行" class="headerlink" title="守护线程的创建和运行"></a>守护线程的创建和运行</h2><p>Java里有一个特殊的线程叫做守护（Daemon）线程。这种线程的优先级很低，通常当一个程序中没有其他线程运行的时候它才运行。当守护线程是程序中唯一运行的线程时，它的结束也就意味着整个程序的结束。<br>因为这种特性，守护线程一般用来作为其他普通线程的服务提供者，通常都是无限循环的，以等待服务请求或者执行线程任务。一个典型的守护线程就是Java的垃圾回收器(Garbage Collector)。<br>下面一个例子：创建两个线程，一个用户线程，它将事件写入到一个队列中；另一个是守护线程，它将管理这个队列，如果生成的事件超过10秒钟，就会被移除。<br><br><br>创建Event类。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Event</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date date;</span><br><span class="line">	<span class="keyword">private</span> String event;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> date;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.date = date;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> event;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEvent</span><span class="params">(String event)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.event = event;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建WriteTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	Deque&lt;Event&gt; deque; <span class="comment">//事件队列</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">WriterTask</span> <span class="params">(Deque&lt;Event&gt; deque)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.deque=deque;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// Writes 100 events</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">100</span>; i++) &#123;</span><br><span class="line">			<span class="comment">//每次循环中都会创建一个新的Event对象，并放入队列</span></span><br><span class="line">			Event event=<span class="keyword">new</span> Event();</span><br><span class="line">			event.setDate(<span class="keyword">new</span> Date());</span><br><span class="line">			event.setEvent(String.format(<span class="string">"The thread %s has generated an event"</span>,Thread.currentThread().getId()));</span><br><span class="line">			deque.addFirst(event);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//休眠一秒</span></span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建CleanerTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanerTask</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Deque&lt;Event&gt; deque;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">CleanerTask</span><span class="params">(Deque&lt;Event&gt; deque)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.deque = deque;</span><br><span class="line">		<span class="comment">//设置为守护线程</span></span><br><span class="line">		setDaemon(<span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			Date date = <span class="keyword">new</span> Date();</span><br><span class="line">			clean(date);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> difference;</span><br><span class="line">		<span class="keyword">boolean</span> delete;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (deque.size()==<span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		delete=<span class="keyword">false</span>;</span><br><span class="line">		do &#123;</span><br><span class="line">			Event e = deque.getLast();</span><br><span class="line">			difference = date.getTime() - e.getDate().getTime();</span><br><span class="line">			<span class="keyword">if</span> (difference &gt; <span class="number">10000</span>) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"Cleaner: %s\n"</span>,e.getEvent());</span><br><span class="line">				deque.removeLast();</span><br><span class="line">				delete=<span class="keyword">true</span>;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125; <span class="keyword">while</span> (difference &gt; <span class="number">10000</span>);</span><br><span class="line">		<span class="keyword">if</span> (delete)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"Cleaner: Size of the queue: %d\n"</span>,deque.size());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		Deque&lt;Event&gt; deque=<span class="keyword">new</span> ArrayDeque&lt;Event&gt;();</span><br><span class="line">		WriterTask writer=<span class="keyword">new</span> WriterTask(deque);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">			Thread thread=<span class="keyword">new</span> Thread(writer);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		CleanerTask cleaner=<span class="keyword">new</span> CleanerTask(deque);</span><br><span class="line">		cleaner.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对程序的分析发现，队列中的对象不断增长直到30个，然后到程序结束，队列的长度维持在27~30之间。<br>这3个WriteTask，每个线程写入一个事件，然后休眠1秒钟。在第一个10秒钟内，队列中有30个事件，直到3个WriteTask都休眠后，CleanerTask才开始执行，但由于事件都小于10秒并未删除任何事件。在接下来的运行中，CleanerTask每秒删除3个对象，同时WriterTask会写入3个对象，所以队列的长度一直介于27~30之间。<br>setDaemon()只能在start()之前才能被调用，一旦线程开始运行，将不能再修改守护状态。<br>isDaemon()用来检查一个线程是不是守护线程。<br><br><br><br></p>
<h2 id="线程中不可控异常的处理"><a href="#线程中不可控异常的处理" class="headerlink" title="线程中不可控异常的处理"></a>线程中不可控异常的处理</h2><p>在java中有两种异常。</p>
<ul>
<li>非运行时异常。 这种异常必须在方法声明的throws语句指定，或者在方法体内捕获。例如IOException和ClassNotFoundException。</li>
<li>运行时异常。 例如：NumberFormatException。<br>因为run()方法不支持throws语句，run()中抛出非运行异常是，必须捕获并且处理它。<br>创建处理运行时异常的类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionHandler</span> <span class="keyword">implements</span> <span class="title">UncaughtExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span>	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"An exception has been captured\n"</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Thread: %s\n"</span>,t.getId());</span><br><span class="line">		System.out.printf(<span class="string">"Exception: %s: %s\n"</span>,e.getClass().getName(),e.getMessage());</span><br><span class="line">		System.out.printf(<span class="string">"Stack Trace: \n"</span>);</span><br><span class="line">		e.printStackTrace(System.out);</span><br><span class="line">		System.out.printf(<span class="string">"Thread status: %s\n"</span>,t.getState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>抛出异常的线程类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> numero=Integer.parseInt(<span class="string">"TTT"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Task task=<span class="keyword">new</span> Task();</span><br><span class="line">		Thread thread=<span class="keyword">new</span> Thread(task);</span><br><span class="line">		thread.setUncaughtExceptionHandler(<span class="keyword">new</span> ExceptionHandler());</span><br><span class="line">		thread.start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			thread.join();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.printf(<span class="string">"Thread has finished\n"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当一个线程抛出异常并且没有被捕获时（这种情况只可能是运行时异常),JVM检查这个线程是否被预置了未捕获异常处理器。如果找到，JVM将调用线程对象的这个方法，并将线程对象和异常作为传入参数。<br>如果线程没有被预置未捕获异常处理器，JVM将打印堆栈记录到控制台，并退出程序。<br>Thread类还有另一个静态方法setDefaultUncaughtExceptionHandler()。这个方法在应用程序中为所有的线程对象创建了一个异常处理器。<br>当线程抛出一个未捕获的异常时，JVM将为异常寻找以下3种可能的处理器。</p>
<ul>
<li>查找线程对象的未捕获异常处理器</li>
<li>(如果上面找不到)JVM将继续查找线程对象所在的线程组(ThreadGroup)的未捕获异常处理器</li>
<li>(如果上面也没找到)JVM将继续查找默认的未捕获异常处理器。<br>如果没有一个处理器存在，JVM打印记录，然后退出。<br><br><br><br><h2 id="线程局部变量的使用"><a href="#线程局部变量的使用" class="headerlink" title="线程局部变量的使用"></a>线程局部变量的使用</h2>  共享数据是并发最核心的问题之一。<br>Java并发API提供了一个干净的机制，即线程局部变量（Thread-Local Variable）。<br>创建线程共享类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnsafeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date startDate;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		startDate=<span class="keyword">new</span> Date();</span><br><span class="line">		System.out.printf(<span class="string">"Starting Thread: %s : %s\n"</span>,Thread.currentThread().getId(),startDate);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep((<span class="keyword">int</span>)Math.rint(Math.random()*<span class="number">10</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Thread Finished: %s : %s\n"</span>,Thread.currentThread().getId(),startDate);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		UnsafeTask task=<span class="keyword">new</span> UnsafeTask();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">			Thread thread=<span class="keyword">new</span> Thread(task);</span><br><span class="line">			thread.start();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个每个线程有一个不同的开始时间，但当它们结束时，都有相同的startDate属性值。<br>用线程局部变量机制解决这个问题。<br>创建SafeTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Date&gt; startDate= <span class="keyword">new</span> ThreadLocal&lt;Date&gt;() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Date <span class="title">initialValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> Date();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Starting Thread: %s : %s\n"</span>,Thread.currentThread().getId(),startDate.get());</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep((<span class="keyword">int</span>)Math.rint(Math.random()*<span class="number">10</span>));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Writes the start date</span></span><br><span class="line">		System.out.printf(<span class="string">"Thread Finished: %s : %s\n"</span>,Thread.currentThread().getId(),startDate.get());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafeMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SafeTask task=<span class="keyword">new</span> SafeTask();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++)&#123;</span><br><span class="line">			Thread thread=<span class="keyword">new</span> Thread(task);</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它跟UnsafeTask类的run()方法实现了一样的功能，但是访问startDate属性的方式改变了。<br>现在，这3个线程对象都有它们自己的startDate属性值。<br>线程局部变量分别为每个线程存储了各自的属性值，并提供给每个线程使用。可以使用get()方法读取这个值，并用set()方法设置这个值。<br>如果线程第一次访问线程局部变量，线程局部变量可能还没有为它存储值，这时initialValue()被调用，并返回当前时间值。<br>线程局部变量也提供了remove()方法。<br>如果一个线程是从其他某个线程中创建的，这个类将提供继承的值。线程A在线程局部变量已有值，当它创建线程B，线程B的线程局部变量将跟线程A是一样的。可以覆盖childValue()方法，这个方法用来初始化子线程在线程局部变量中的值。它使用父线程在线程局部变量中的值作为传入参数。<br><br><br></p>
<h2 id="线程的分组"><a href="#线程的分组" class="headerlink" title="线程的分组"></a>线程的分组</h2><p>Java并发API提供了把线程分组，对组内线程对象进行访问并操作它们。例如，对于一些执行同样任务的线程，不管组内多少线程在运行，只需要一个单一的调用，所有这些线程的运行都会被中断。<br>ThreadGroup类表示一组线程。    线程组可以包含线程对象，也可以包含其他线程组对象，它是一个树形结构。<br>下面创建10个线程查询相同的任务并让它们随机休眠一段时间，当其中一个线程查询到结果，将其他9个线程中断。<br>创建Result类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建SearchTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SearchTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Result result;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">SearchTask</span><span class="params">(Result result)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.result=result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		String name=Thread.currentThread().getName();</span><br><span class="line">		System.out.printf(<span class="string">"Thread %s: Start\n"</span>,name);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			doTask();</span><br><span class="line">			result.setName(name);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"Thread %s: Interrupted\n"</span>,name);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Thread %s: End\n"</span>,name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">		Random random=<span class="keyword">new</span> Random((<span class="keyword">new</span> Date()).getTime());</span><br><span class="line">		<span class="keyword">int</span> value=(<span class="keyword">int</span>)(random.nextDouble()*<span class="number">100</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Thread %s: %d\n"</span>,Thread.currentThread().getName(),value);</span><br><span class="line">		TimeUnit.SECONDS.sleep(value);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		ThreadGroup threadGroup = <span class="keyword">new</span> ThreadGroup(<span class="string">"Searcher"</span>);</span><br><span class="line">		Result result=<span class="keyword">new</span> Result();</span><br><span class="line"></span><br><span class="line">		SearchTask searchTask=<span class="keyword">new</span> SearchTask(result);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">			Thread thread=<span class="keyword">new</span> Thread(threadGroup, searchTask);</span><br><span class="line">			thread.start();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		System.out.printf(<span class="string">"Number of Threads: %d\n"</span>,threadGroup.activeCount());</span><br><span class="line">		System.out.printf(<span class="string">"Information about the Thread Group\n"</span>);</span><br><span class="line">		threadGroup.list();</span><br><span class="line"></span><br><span class="line">		Thread[] threads=<span class="keyword">new</span> Thread[threadGroup.activeCount()];</span><br><span class="line">		threadGroup.enumerate(threads);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;threadGroup.activeCount(); i++) &#123;</span><br><span class="line">			System.out.printf(<span class="string">"Thread %s: %s\n"</span>,threads[i].getName(),threads[i].getState());</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		waitFinish(threadGroup);</span><br><span class="line">		threadGroup.interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitFinish</span><span class="params">(ThreadGroup threadGroup)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (threadGroup.activeCount()&gt;<span class="number">9</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程组类存储了线程对象和关联的线程组对象，并可以访问它们的信息（例如状态），将执行的操作应用到所有成员上（例如中断）。</p>
<p><br><br></p>
<h2 id="线程组中不可控异常的处理"><a href="#线程组中不可控异常的处理" class="headerlink" title="线程组中不可控异常的处理"></a>线程组中不可控异常的处理</h2><p>Java提供了捕获和处理异常的机制。<br>有的异常必须被捕获，或者必须使用方法的throws声明再次抛出，这类异常叫做非运行时异常。<br>还有一类异常叫做运行时异常，它们不需要被什么或者捕获。<br>建立一个方法来捕获线程组中的任何线程对象抛出的非捕获异常。<br>创建一个MyThreadGroup类，并继承ThreadGroup。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadGroup</span> <span class="keyword">extends</span> <span class="title">ThreadGroup</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThreadGroup</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"The thread %s has thrown an Exception\n"</span>,t.getId());</span><br><span class="line">		e.printStackTrace(System.out);</span><br><span class="line">		System.out.printf(<span class="string">"Terminating the rest of the Threads\n"</span>);</span><br><span class="line">		interrupt();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> result;</span><br><span class="line">		Random random=<span class="keyword">new</span> Random(Thread.currentThread().getId());</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			result=<span class="number">1000</span>/((<span class="keyword">int</span>)(random.nextDouble()*<span class="number">1000</span>));</span><br><span class="line">			System.out.printf(<span class="string">"%s : %f\n"</span>,Thread.currentThread().getId(),result);</span><br><span class="line">			<span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">				System.out.printf(<span class="string">"%d : Interrupted\n"</span>,Thread.currentThread().getId());</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThreadGroup threadGroup=<span class="keyword">new</span> MyThreadGroup(<span class="string">"MyThreadGroup"</span>);</span><br><span class="line">		Task task=<span class="keyword">new</span> Task();</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">			Thread t=<span class="keyword">new</span> Thread(threadGroup,task);</span><br><span class="line">			t.start();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面说过，当线程抛出非捕获异常时，JVM将为这个异常寻找3种可能的处理器。<br>首先，寻找抛出这个异常的线程的非捕获异常处理器，如果这个处理器不存在，JVM继续查找这个线程所在线程组的非捕获异常处理器，上面的代码就是这种情况。</p>
<p><br> <br></p>
<h2 id="使用工厂类创建线程"><a href="#使用工厂类创建线程" class="headerlink" title="使用工厂类创建线程"></a>使用工厂类创建线程</h2><h4 id="使用工厂类，可以将对象的创建集中化，这样做的好处："><a href="#使用工厂类，可以将对象的创建集中化，这样做的好处：" class="headerlink" title="使用工厂类，可以将对象的创建集中化，这样做的好处："></a>使用工厂类，可以将对象的创建集中化，这样做的好处：</h4><ul>
<li>更容易修改类，或者改变创建对象的方式</li>
<li>更容易为有限资源限制对象的数目。例如，可以限制一个类型的对象不多于n个。</li>
<li>更容易为创建的对象生成统计数据。<br><br><br>Java提供了ThreadFactory接口。Java并发API的高级工具类也使用了线程工厂创建线程。<br>创建MyThreadFactory类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> counter;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; stats;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MyThreadFactory</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		counter=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">this</span>.name=name;</span><br><span class="line">		stats=<span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">		Thread t=<span class="keyword">new</span> Thread(r,name+<span class="string">"-Thread_"</span>+counter);</span><br><span class="line">		counter++;</span><br><span class="line">		stats.add(String.format(<span class="string">"Created thread %d with name %s on %s\n"</span>,t.getId(),t.getName(),<span class="keyword">new</span> Date()));</span><br><span class="line">		<span class="keyword">return</span> t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getStats</span><span class="params">()</span></span>&#123;</span><br><span class="line">		StringBuffer buffer=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">		Iterator&lt;String&gt; it=stats.iterator();</span><br><span class="line">		<span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">			buffer.append(it.next());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> buffer.toString();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		MyThreadFactory factory=<span class="keyword">new</span> MyThreadFactory(<span class="string">"MyThreadFactory"</span>);</span><br><span class="line">		Task task=<span class="keyword">new</span> Task();</span><br><span class="line">		Thread thread;</span><br><span class="line">		</span><br><span class="line">		System.out.printf(<span class="string">"Starting the Threads\n"</span>);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">			thread=factory.newThread(task);</span><br><span class="line">			thread.start();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Factory stats:\n"</span>);</span><br><span class="line">		System.out.printf(<span class="string">"%s\n"</span>,factory.getStats());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadFactory接口只有一个方法，即newThread，它以Runnable接口对象作为传入参数并且返回一个线程对象。当实现ThreadFactory接口时，必须实现覆盖这个方法。<br>可以通过增加一些变化来强化实现方法覆盖。</p>
<ul>
<li>创建一个个性化线程，如使用一个特殊的格式作为线程名，或者通过继承Thread类来创建自己的线程类</li>
<li>保存新创建的线程的统计数据</li>
<li>限制创建的线程的数量</li>
<li>对生成的线程进行验证<br><br><br>使用工厂设计模式是一个很好的编程实践，如果通过实现ThreadFactory接口来创建线程，以保证所有的线程都是使用这个工厂创建的。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/04/22/一步一步精通Java多线程/" data-id="civ9ktzly000ajogfvegjmmq8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-开始我的博客" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/21/开始我的博客/" class="article-date">
  <time datetime="2016-04-21T02:36:15.000Z" itemprop="datePublished">2016-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/21/开始我的博客/">开始我的博客</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>这个博客会记录一个阶段学习的内容和总结</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/04/21/开始我的博客/" data-id="civ9ktzly000cjogfvkftu0xb" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/16/安全加密认证基础知识/">安全加密认证基础知识</a>
          </li>
        
          <li>
            <a href="/2016/09/13/RX前传/">RX前传</a>
          </li>
        
          <li>
            <a href="/2016/08/08/源码分析OKHttp/">源码分析OKHttp</a>
          </li>
        
          <li>
            <a href="/2016/08/05/doc-ppt-online/">在线预览ppt doc</a>
          </li>
        
          <li>
            <a href="/2016/07/21/Java注解/">Java注解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Jimmy Yao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>