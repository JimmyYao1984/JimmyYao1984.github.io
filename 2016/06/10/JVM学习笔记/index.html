<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>JVM学习笔记 | Jimmy的日记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="整数的表达在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

原码——第一位为符号位（0为整数，1为负数）
反码——符号位不懂，原码取反
负数补码——符号为不动，反码加1
正数补码——和原码相同123456//打印整数的二进制表示int a = -6;f">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM学习笔记">
<meta property="og:url" content="http://JimmyYao984.github.io/2016/06/10/JVM学习笔记/index.html">
<meta property="og:site_name" content="Jimmy的日记">
<meta property="og:description" content="整数的表达在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

原码——第一位为符号位（0为整数，1为负数）
反码——符号位不懂，原码取反
负数补码——符号为不动，反码加1
正数补码——和原码相同123456//打印整数的二进制表示int a = -6;f">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606100140.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606101524.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606102021.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606102053.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606112339.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606120126.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122214.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122213.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122230.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122233.png">
<meta property="og:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122306.png">
<meta property="og:updated_time" content="2016-10-31T06:00:21.164Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM学习笔记">
<meta name="twitter:description" content="整数的表达在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

原码——第一位为符号位（0为整数，1为负数）
反码——符号位不懂，原码取反
负数补码——符号为不动，反码加1
正数补码——和原码相同123456//打印整数的二进制表示int a = -6;f">
<meta name="twitter:image" content="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606100140.png">
  
    <link rel="alternate" href="/atom.xml" title="Jimmy的日记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jimmy的日记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">study new skill step by step</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://JimmyYao984.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JVM学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/10/JVM学习笔记/" class="article-date">
  <time datetime="2016-06-09T17:07:22.000Z" itemprop="datePublished">2016-06-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JVM学习笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="整数的表达"><a href="#整数的表达" class="headerlink" title="整数的表达"></a>整数的表达</h2><p>在计算机系统中，数值一律用补码来表示和存储。<br>原因在于，使用补码，可以将符号位和数值域统一处理；<br>同时，加法和减法也可以统一处理。<br>此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p>
<ul>
<li>原码——第一位为符号位（0为整数，1为负数）</li>
<li>反码——符号位不懂，原码取反</li>
<li>负数补码——符号为不动，反码加1</li>
<li>正数补码——和原码相同<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打印整数的二进制表示</span></span><br><span class="line"><span class="keyword">int</span> a = -<span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">   <span class="keyword">int</span> t = (a &amp; <span class="number">0x80000000</span>&gt;&gt;&gt;i)&gt;&gt;&gt;(<span class="number">31</span>-i);</span><br><span class="line">   System.out.print(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><br> <br> <br></p>
<h2 id="JVM需要对Java-Library提供以下支持"><a href="#JVM需要对Java-Library提供以下支持" class="headerlink" title="JVM需要对Java Library提供以下支持"></a>JVM需要对Java Library提供以下支持</h2><ul>
<li>反射java.lang.reflect</li>
<li>ClassLoader</li>
<li>初始化class和interface</li>
<li>安全相关java.security</li>
<li>多线程</li>
<li>弱引用<br><br> <br> <br></li>
</ul>
<h2 id="JVM启动流程"><a href="#JVM启动流程" class="headerlink" title="JVM启动流程"></a>JVM启动流程</h2><p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606100140.png" alt="Mark-Down"></p>
<p><br> <br> <br></p>
<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606101524.png" alt="Mark-Down"></p>
<p>Java栈是线程私有的，Java堆是全局共享的。</p>
<h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><p>每个线程拥有一个PC寄存器<br>在线程创建时创建<br>指向下一条指令的地址<br>执行本地方法时，PC的值为undefined</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>保存装载的类信息</p>
<ul>
<li>类型的常量池</li>
<li>字段，方法信息</li>
<li>方法字节码<br>通常和永久区（Perm）关联在一起<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3>和程序开发密切相关<br>应用系统对象都保存在Java堆中<br>所有线程共享Java堆<br>对分代GC来说，堆也是分代的<br>GC的主要工作区间<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606102021.png" alt="Mark-Down"></li>
</ul>
<h3 id="Java栈"><a href="#Java栈" class="headerlink" title="Java栈"></a>Java栈</h3><p>线程私有<br>栈由一系列帧组成（因此Java栈也叫做帧栈）<br>帧保存一个方法的局部变量、操作数栈、常量池指针<br>每一个方法调用创建一个帧，并压栈<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackDemo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStatic</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">long</span> l, <span class="keyword">float</span> f, Object o, <span class="keyword">byte</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">runInstance</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">short</span> s, <span class="keyword">boolean</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606102053.png" alt="Mark-Down"></p>
<p><br> <br> <br></p>
<h2 id="Java栈上分配"><a href="#Java栈上分配" class="headerlink" title="Java栈上分配"></a>Java栈上分配</h2><p>小对象（一般几十个bytes），在没有逃逸的情况下，可以直接分配在栈上<br>直接分配在栈上，可以自动回收，减轻GC压力<br>大对象或者逃逸对象无法栈上分配<br><br> <br> <br></p>
<h2 id="栈、堆、方法区交互"><a href="#栈、堆、方法区交互" class="headerlink" title="栈、堆、方法区交互"></a>栈、堆、方法区交互</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppMain</span></span>&#123; <span class="comment">//运行时，jvm把appmain的信息都放入方法区</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; <span class="comment">//main方法本身放入方法区</span></span><br><span class="line">        Sample test1 = <span class="keyword">new</span> Sample(<span class="string">"测试1"</span>); <span class="comment">//test1引用，所以放到栈区，Sample是自定义对象应该放到堆里面</span></span><br><span class="line">        Sample test2 = <span class="keyword">new</span> Sample(<span class="string">"测试2"</span>);</span><br><span class="line"></span><br><span class="line">        test1.printName();</span><br><span class="line">        test2.printName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sample</span></span>&#123; <span class="comment">//运行时，jvm把appmain的信息都放入方法区</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">//new Sample实例后，name引用放入栈区里name对象放入堆里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Sample</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//print方法本身放入方法区里</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606112339.png" alt="Mark-Down"></p>
<p><br><br> <br></p>
<h2 id="工作内存和主存"><a href="#工作内存和主存" class="headerlink" title="工作内存和主存"></a>工作内存和主存</h2><p>当数据从主内存复制到工作存储时，必须出现两个动作</p>
<ul>
<li>由主内存执行的读（read）操作</li>
<li>由工作内存执行的相应的load操作<br><br><br>当数据从工作内存拷贝到主内存时，也出现两个操作</li>
<li>由工作内存执行的存储(store)操作</li>
<li>由主内存执行的相应的写(write)操作<br><br><br>每一个操作都是原子的，即执行期间不会被中断<br>对于普通变量，一个线程中更新的值，不能马上反应在其他变量中<br>如果需要在其他线程中立即可见，需要使用volatile关键字<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606120126.png" alt="Mark-Down"></li>
</ul>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><ul>
<li>在本线程内，操作都是有序的</li>
<li>在线程外观察，操作都是无序的。（指令重排或主内存同步延时）<br><br><h4 id="指令重排的基本原则"><a href="#指令重排的基本原则" class="headerlink" title="指令重排的基本原则"></a>指令重排的基本原则</h4></li>
<li>程序顺序原则：一个线程内保证语义的串行性</li>
<li>volatile规则：volatile变量的写，先发生于读</li>
<li>锁规则：解锁（unlock）必然发生在随后的加锁（lock）前</li>
<li>传递性：A先于B，B先于C，那么A必然先于C</li>
<li>线程的start方法先于它的每一个动作</li>
<li>线程的所有操作先于线程的终结（Thread.join()）</li>
<li>线程的中断（interrupt()）先于被中断线程的代码</li>
<li>对象的构造函数执行结束先于finalize()方法<br><br> <br> <br><h2 id="几种常见的GC算法"><a href="#几种常见的GC算法" class="headerlink" title="几种常见的GC算法"></a>几种常见的GC算法</h2></li>
<li>引用计数法</li>
<li>标记-清除法</li>
<li>标记-压缩法</li>
<li>复制算法<br><br><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4>老牌垃圾回收算法<br>通过引用计数来回收垃圾<br>使用者：COM、ActionScript3、Python<br>缺陷：引用和去引用伴随加法和减法，影响性能；很难处理循环引用问题<br><br><h4 id="标记-清除"><a href="#标记-清除" class="headerlink" title="标记-清除"></a>标记-清除</h4>标记阶段：通过根节点，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象。<br>清除阶段：清除所有未被标记的对象。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122214.png" alt="Mark-Down"></li>
</ul>
<p><br></p>
<h4 id="标记-压缩"><a href="#标记-压缩" class="headerlink" title="标记-压缩"></a>标记-压缩</h4><p>它是标记-清除的优化，先标记，但之后并不简单的清理未被标记的对象，而是将所有的存活对象压缩到内存的一端。<br>之后，清理边界外所有空间。这样做，减少了内存碎片。<br> [标记-压缩] 算法适用于存活对象较多的场合，如老年代。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122213.png" alt="Mark-Down"></p>
<p><br></p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>与标记-清除算法相比，复制算法是一种相对高效的回收方法。<br>不适用于存活对象较多的场合，如老年代。<br>将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，<br>之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122230.png" alt="Mark-Down"></p>
<p>复制算法的最大问题是：空间浪费 整合标记清理思想<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122233.png" alt="Mark-Down"></p>
<p><br></p>
<h4 id="分代思想"><a href="#分代思想" class="headerlink" title="分代思想"></a>分代思想</h4><ul>
<li>依据对象的存活周期进行分类，短命对象归为新生代，长命对象归为老年代。</li>
<li>根据不同代的特点，选取合适的收集算法：少量对象存活，适合复制算法；大量对象存活，适合标记清理或标记压缩算法。<br><br><h4 id="可触及性"><a href="#可触及性" class="headerlink" title="可触及性"></a>可触及性</h4></li>
<li>可触及的：从根节点可以触及到这个对象</li>
<li>可复活的：一旦所有引用被释放，就是可复活状态，因为finalize()中可能复活该对象</li>
<li>不可触及的：在finalize()后，可能会进入不可触及状态，不可触及的对象不可能复活，可以回收<br>避免使用finalize(),操作不慎可能导致错误。可以使用try-catch-finally来替代它。<br><br></li>
</ul>
<h4 id="STOP-THE-WORLD"><a href="#STOP-THE-WORLD" class="headerlink" title="STOP_THE_WORLD"></a>STOP_THE_WORLD</h4><p>Java中一种全局暂停的现象。<br>全局停顿，所有Java代码停止，native可以执行，但不能和JVM交互。<br>多半由于GC引起。</p>
<ul>
<li>Dump线程</li>
<li>死锁检查</li>
<li>堆Dump<br>危害：长时间服务停止，没有响应；遇到HA系统，可能引起主备切换，严重危害生产环境。<br><br></li>
</ul>
<h2 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h2><h4 id="class装载验证流程"><a href="#class装载验证流程" class="headerlink" title="class装载验证流程"></a>class装载验证流程</h4><p>加载——&gt;链接[验证、准备、解析]——&gt;初始化</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>装载类的第一个阶段<br>取得类的二进制流<br>转为方法区数据结构<br>在Java堆中生成对应的java.lang.Class对象</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>目的：保证Class流的格式是正确的</p>
<ul>
<li>文件格式的验证</li>
<li>元数据验证</li>
<li>字节码验证（很复杂）</li>
<li>符号引用验证<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4>分配内存，并为类设置初始值（方法区中）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> v = <span class="number">1</span>; <span class="comment">//在准备阶段找那个，v会被设置为0，在初始化的&lt;clinit&gt;中才会被设置为1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> v = <span class="number">1</span>; <span class="comment">//对于static final类型，在准备阶段就会被赋上正确的值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>符号引用替换为直接引用。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>执行类构造器<clinit>,static变量赋值语句，static{}语句。<br>子类的<clinit>调用前保证父类的<clinit>被调用。</clinit></clinit></clinit></p>
<p><clinit>是线程安全的。<br><br></clinit></p>
<h2 id="什么是ClassLoader"><a href="#什么是ClassLoader" class="headerlink" title="什么是ClassLoader"></a>什么是ClassLoader</h2><p>ClassLoader是一个抽象<br>ClassLoader的实例将读入Java字节码将类装载到JVM中<br>ClassLoader可以定制，满足不同的字节码流获取方式<br>ClassLoader负责类装载过程中的加载阶段<br>ClassLoad的重要方法</p>
<ul>
<li>public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException 载入并返回一个Class</li>
<li>protected final Class&lt;?&gt; defineClass(byte[] b, int off, int len) 定义一个类，不公开调用</li>
<li>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException loadClass回调方法，自定义ClassLoader的推荐做法</li>
<li>protected final Class&lt;?&gt; findLoadedClass(String name) 寻找已经加载的类</li>
</ul>
<h2 id="JDK中ClassLoader默认设计模式"><a href="#JDK中ClassLoader默认设计模式" class="headerlink" title="JDK中ClassLoader默认设计模式"></a>JDK中ClassLoader默认设计模式</h2><p>BootStrap ClassLoader(启动ClassLoader)<br>Extension ClassLoader(扩展ClassLoader)<br>App ClassLoader(应用ClassLoader/系统ClassLoader)<br>Custom ClassLoader(自定义ClassLoader)<br>每个ClassLoader都有一个Parent作为父亲。<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606122306.png" alt="Mark-Down"></p>
<p>双亲模式的问题：顶层ClassLoader，无法加载底层ClassLoader的类。<br>解决办法：Thread.setContextClassLoader()，上下文加载器，基本思想是，在顶层ClassLoader中，传入底层ClassLoader的实例。<br>双亲模式是默认的模式，但不是必须这么做，Tomcat的WebappClassLoader就会先加载自己的Class，找不到再委托parent；<br>OSGi的ClassLoader形成网状结构，根据需要自由加载Class。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/06/10/JVM学习笔记/" data-id="civ9ktzk80002jogf0texai7r" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/06/13/Java设计模式/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Java设计模式
        
      </div>
    </a>
  
  
    <a href="/2016/06/07/Java核心技术阅读笔记/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java核心技术阅读笔记</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/09/16/安全加密认证基础知识/">安全加密认证基础知识</a>
          </li>
        
          <li>
            <a href="/2016/09/13/RX前传/">RX前传</a>
          </li>
        
          <li>
            <a href="/2016/08/08/源码分析OKHttp/">源码分析OKHttp</a>
          </li>
        
          <li>
            <a href="/2016/08/05/doc-ppt-online/">在线预览ppt doc</a>
          </li>
        
          <li>
            <a href="/2016/07/21/Java注解/">Java注解</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Jimmy Yao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>