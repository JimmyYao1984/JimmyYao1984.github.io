<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Java多线程 0x04 | Jimmy的日记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="知识点
创建线程执行器
创建固定大小的线程执行器
在执行器中执行任务并返回结果
运行多个任务并处理第一个结果
运行多个任务并处理所有结果
在执行器中延时执行任务
在执行器中周期性执行任务
在执行器中取消任务
在执行器中控制任务的完成
在执行器中分离任务的启动与结果的处理
处理在执行器中被拒绝的任务

通常Java开发一个简单的并发任务，会创建Runnable对象，并创建对应的Thread的对象来执">
<meta property="og:type" content="article">
<meta property="og:title" content="Java多线程 0x04">
<meta property="og:url" content="http://JimmyYao984.github.io/2016/05/13/一步一步精通Java多线程4/index.html">
<meta property="og:site_name" content="Jimmy的日记">
<meta property="og:description" content="知识点
创建线程执行器
创建固定大小的线程执行器
在执行器中执行任务并返回结果
运行多个任务并处理第一个结果
运行多个任务并处理所有结果
在执行器中延时执行任务
在执行器中周期性执行任务
在执行器中取消任务
在执行器中控制任务的完成
在执行器中分离任务的启动与结果的处理
处理在执行器中被拒绝的任务

通常Java开发一个简单的并发任务，会创建Runnable对象，并创建对应的Thread的对象来执">
<meta property="og:updated_time" content="2016-06-06T07:45:37.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java多线程 0x04">
<meta name="twitter:description" content="知识点
创建线程执行器
创建固定大小的线程执行器
在执行器中执行任务并返回结果
运行多个任务并处理第一个结果
运行多个任务并处理所有结果
在执行器中延时执行任务
在执行器中周期性执行任务
在执行器中取消任务
在执行器中控制任务的完成
在执行器中分离任务的启动与结果的处理
处理在执行器中被拒绝的任务

通常Java开发一个简单的并发任务，会创建Runnable对象，并创建对应的Thread的对象来执">
  
    <link rel="alternate" href="/atom.xml" title="Jimmy的日记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jimmy的日记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">study new skill step by step</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://JimmyYao984.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-一步一步精通Java多线程4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/13/一步一步精通Java多线程4/" class="article-date">
  <time datetime="2016-05-13T03:02:38.000Z" itemprop="datePublished">2016-05-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Java多线程 0x04
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul>
<li>创建线程执行器</li>
<li>创建固定大小的线程执行器</li>
<li>在执行器中执行任务并返回结果</li>
<li>运行多个任务并处理第一个结果</li>
<li>运行多个任务并处理所有结果</li>
<li>在执行器中延时执行任务</li>
<li>在执行器中周期性执行任务</li>
<li>在执行器中取消任务</li>
<li>在执行器中控制任务的完成</li>
<li>在执行器中分离任务的启动与结果的处理</li>
<li>处理在执行器中被拒绝的任务</li>
</ul>
<p>通常Java开发一个简单的并发任务，会创建Runnable对象，并创建对应的Thread的对象来执行它们。<br>但是，如果开发一个运行大量的并发任务，这个方法将突显以下劣势</p>
<ul>
<li>必须实现所有与Thread对象管理相关的代码，如线程的创建、结束以及结果获取。</li>
<li>需要为每个任务创建一个Thread对象。如果需要执行大量的任务，这将大大地影响应用程序的处理能力。</li>
<li>计算机的资源需要高效地进行控制和管理，创建过多的线程，将会导致系统负荷过重。</li>
</ul>
<p>自JDK5之后，Java并发API提供了一套执行器框架（Executor Framework），它围绕着Executor接口和它的子接口ExecutorService，以及实现这两个接口的ThreadPoolExecutor类展开。<br>这套机制分离了任务的创建和执行，通过使用执行器，仅需要实现Runnable接口的对象，然后将这些对象发送给执行器即可。<br>执行器通过创建所需的线程，来负责这些Runnable对象的创建、实例化以及运行。<br>执行器使用了线程池来提高应用程序的性能。当发送一个任务给执行器时，执行器会尝试使用线程池中的线程来执行这个任务，避免了不断地创建和销毁线程而导致系统性能下降。</p>
<p>执行器框架另一个重要的优势是Callable接口，它类似于Runnable接口，但提供了两方面的增加：</p>
<ul>
<li>接口主方法名为call()，可以返回结果</li>
<li>当发送一个Callable对象给执行器时，将获得一个实现了Future接口的对象。可以使用这个Future对象控制Callable对象的状态和结果。<br><br><br><h2 id="创建执行器"><a href="#创建执行器" class="headerlink" title="创建执行器"></a>创建执行器</h2>执行器框架的第一步是创建ThreadPoolExecutor对象。<br>可以使用ThreadPoolExecutor类提供的四个构造器来创建ThreadPoolExecutor对象，也可以使用Executors工厂类来创建。<br>创建Task类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="comment">//存储任务的创建时间</span></span><br><span class="line">	<span class="keyword">private</span> Date initDate;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//存储任务的名称</span></span><br><span class="line">	<span class="keyword">private</span> String name; </span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		initDate = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建时间</span></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Created on: %s\n"</span>, Thread.currentThread().getName(), name, initDate);</span><br><span class="line">		<span class="comment">//开始时间</span></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Started on: %s\n"</span>,Thread.currentThread().getName(),name,<span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s: Task %s: Doing a task during %d seconds\n"</span>, Thread.currentThread().getName(), name, duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//结束时间</span></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Finished on: %s\n"</span>, Thread.currentThread().getName(), name, <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建Server类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor = (ThreadPoolExecutor) Executors.newCachedThreadPool();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Server: A new task has arrived\n"</span>);</span><br><span class="line">		executor.execute(task);</span><br><span class="line">		System.out.printf(<span class="string">"Server: Pool Size: %d\n"</span>,executor.getPoolSize());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Active Count: %d\n"</span>,executor.getActiveCount());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Completed Tasks: %d\n"</span>,executor.getCompletedTaskCount());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Server server = <span class="keyword">new</span> Server();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task "</span> + i);</span><br><span class="line">			server.executeTask(task);</span><br><span class="line">		&#125;</span><br><span class="line">		server.endServer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Executors工厂类的newCachedThreadPool()方法创建了一个缓存线程池。<br>这个方法强制转换为ThreadPoolExecutor类型，并拥有所有的方法。<br>如果需要执行新任务，缓存线程池就会创建新线程；如果线程所允许的任务执行完成后并且这个线程可用，那么缓存线程池将会重用这些线程。线程重用的优点是减少了创建线程所花费的时间。然而，新任务固定会依赖线程来执行，因此晕车线程池也有缺点，如果发送过多的任务给执行器，系统的负荷将会过载。</p>
<h5 id="仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool-方法来创建执行器。"><a href="#仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool-方法来创建执行器。" class="headerlink" title="仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool()方法来创建执行器。"></a>仅当线程的数量是合理的或者线程只会运行很短的时间时，适合采用Executors工厂类的newCachedThreadPool()方法来创建执行器。</h5><p>一旦创建了执行器，就可以使用executed()方法来发送Runnable或Callable任务。<br>ThreadPoolExecutor有以下方法</p>
<ul>
<li>getPoolSize() 返回执行器线程池中的实际的线程数</li>
<li>getActiveCount() 返回执行器中正在执行任务的线程数</li>
<li>getCompletedTaskCount() 返回执行器已经完成的任务数</li>
<li>getLargestPoolSize() 返回曾经同时位于线程池中的最大线程数</li>
<li>shutdownNow() 这个方法立即关闭执行器。执行器将不再执行那些正在等待执行的任务。将返回等待执行任务的列表。正在执行的任务还将继续执行，但不等待这些任务完成。</li>
<li>isTerminated() 如果调用了shutdown()或shutdownNow()方法，并且执行器完成了关闭的过程，那么返回true。</li>
<li>isShutdown() 调用了shutdown()返回true</li>
<li>awaitTermination(long timeout,TimeUnit unit) 这个方法将阻塞所调用的线程，直到执行器完成任务或者达到所指定的timeout值。如果想等待任务的结束，而不管任务的持续时间，可以使用一个大的超时时间，比如DAYS。<h5 id="ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。"><a href="#ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。" class="headerlink" title="ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。"></a>ThreadPoolExecutor类还有一个重要特性，必须主动地结束它。</h5><br><br></li>
</ul>
<h2 id="创建固定大小的线程执行器"><a href="#创建固定大小的线程执行器" class="headerlink" title="创建固定大小的线程执行器"></a>创建固定大小的线程执行器</h2><p>Executors提供了一个方法来创建一个固定大小的线程执行器。<br>这个执行器有一个线程数的最大值，如果发送超过这个最大值，执行器将不再创建额外的线程，剩下的任务将被阻塞直到执行器有空闲的线程可用。这可以保证执行器不会给应用程序带来性能不佳的问题。<br>创建Server类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ThreadPoolExecutor executor;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor = (ThreadPoolEexcutor)Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeTask</span><span class="params">(Task task)</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Server: A new task has arrived\n"</span>);</span><br><span class="line">		executor.execute(task);</span><br><span class="line">		System.out.printf(<span class="string">"Server: Pool Size: %d\n"</span>, executor.getPoolSize());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Active Count: %d\n"</span>, executor.getActiveCount());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Task Count: %d\n"</span>,executor.getTaskCount());</span><br><span class="line">		System.out.printf(<span class="string">"Server: Completed Task: %d\n"</span>, executor.getCompletedTaskCount());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endService</span><span class="params">()</span></span>&#123;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Date initDate;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		initDate = <span class="keyword">new</span> Date();</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s : Created on: %s\n"</span>, Thread.currentThread().getName(), name, initDate);</span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Started on: %s\n"</span>, Thread.currentThread().getName(), name, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random() * <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s: Task %s: Doing a task during %d seconds\n"</span>, Thread.currentThread().getName(), name, duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"%s: Task %s: Finished on: %s\n"</span>, Thread.currentThread().getName(), <span class="keyword">new</span> Date(), name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		Server server = <span class="keyword">new</span> Server();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task "</span> + i);</span><br><span class="line">			server.executeTask(task);</span><br><span class="line">		&#125;</span><br><span class="line">		server.endServer();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用Executors工厂类newFiexedThreadPool()创建执行器。<br>Executors工厂类还提供了newSingleThreadExecutors()方法。这是一个创建固定大小线程执行器的极端情况，它将创建一个只有单个线程的执行器。因此，这个执行器只能在同一时间执行一个任务。<br><br>　<br></p>
<h2 id="在执行器中执行任务并返回结果"><a href="#在执行器中执行任务并返回结果" class="headerlink" title="在执行器中执行任务并返回结果"></a>在执行器中执行任务并返回结果</h2><p>执行器框架的优势之一是，可以在运行并发任务并返回结果。<br>Callable：这个接口声明了call()方法。可以在这个方法里实现任务的具体逻辑操作。Callable接口时一个泛型接口，这意味着必须声明call()方法返回的数据类型。<br>Future:这个接口声明了一些方法来获取由Callable对象产生的结果，并管理它们的状态。<br>创建FactorialCalculator类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialCalculator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">	<span class="comment">//存储任务计算的数字</span></span><br><span class="line">	<span class="keyword">private</span> Integer number;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">FactorialCalculator</span><span class="params">(Integer number)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.number = number;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">int</span> num, result;</span><br><span class="line">		num = number.intValue();</span><br><span class="line">		result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span>((num == <span class="number">0</span> || (num == <span class="number">1</span>))&#123;</span><br><span class="line">			result = <span class="number">1</span>;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= number; i++)&#123;</span><br><span class="line">				result *= i;</span><br><span class="line">				Thread.sleep(<span class="number">20</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"%s: %d\n"</span>, Thread.currentThread().getName(), result);</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">		<span class="comment">//创建一个Future&lt;Integer&gt;类型的列表对象resultList</span></span><br><span class="line">		List&lt;Future&lt;Integer&gt;&gt; resultList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">			Integer number = <span class="keyword">new</span> Integer(random.nextInt(<span class="number">10</span>));</span><br><span class="line">			FactorialCalculator calculator = <span class="keyword">new</span> FactorialCalculator(number);</span><br><span class="line">			Future&lt;Integer&gt; result = executor.submit(calculator);</span><br><span class="line">			resultList.add(result);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		do&#123;</span><br><span class="line">			<span class="comment">//任务完成的数量</span></span><br><span class="line">			System.out.printf(<span class="string">"Main: Number of Completed Tasks: %d\n"</span>,executor.getCompletedTaskCount());</span><br><span class="line">			<span class="comment">//遍历10个Future对象，通过isDone()输出任务是否完成</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; resultList.size(); i++)&#123;</span><br><span class="line">				Future&lt;Integer&gt; result = resultList.get(i);</span><br><span class="line">				System.out.printf(<span class="string">"Main: Task %d: %s\n"</span>, result.isDone());</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Thread.sleep(<span class="number">50</span>);</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;<span class="keyword">while</span>(executor.getCompletedTaskCount()&lt;resultList.size());</span><br><span class="line">		System.out.printf(<span class="string">"Main: Results\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; resultList.size(); i++)&#123;</span><br><span class="line">			Future&lt;Integer&gt; result = resultList.get(i);</span><br><span class="line">			Integer number = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				number = result.get();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.printf(<span class="string">"Core: Task %d: %d\n"</span>,i,number);</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现了带有泛型参数Integer类型的Callable接口，因此这个Integer类型将作为在调用call()方法时的返回的类型。<br>通过submit()发送一个Callable对象给执行器去执行，这个submit()方法接受Callable对象作为参数，并返回Future对象。<br>Future对象可以用于以下两个主要目的</p>
<ul>
<li>控制任务的状态：可以取消任务和检查任务是否已完成。为了达到这个目的，可使用isDone()方法来检查任务是否已完成。</li>
<li>通过call()方法获取返回的结果。为了达到这个目的，可使用get()方法。这个方法一直等待直到Callable对象的call()方法执行并返回结果。如果get()方法在等待结果时线程中断了，则抛出一个InterruptedException异常。如果call()方法抛出异常那么get()方法将随之抛出ExecutionException异常。<br>在调用Future对象的get()方法时，如果Future对象所控制的任务并未完成，那么这个方法将一直阻塞到任务完成。还有其他形式的get()</li>
<li>get(long timeout, TimeUnit unit):调用这个方法时，任务的结果并未准备好，则方法等待所指定的timeout时间。如果等待超过了指定的时间而任务的结果还没有准备好，那么这个方法将返回null。<br><br> <br><h2 id="运行多个任务并处理第一个结果"><a href="#运行多个任务并处理第一个结果" class="headerlink" title="运行多个任务并处理第一个结果"></a>运行多个任务并处理第一个结果</h2>并发编程比较常见的一个问题，当采用多个并发任务解决一个问题时，往往只关心这些任务中的第一个结果。<br>比如，对一个数组进行排序有很多算法，可以并发启动所有算法，但是对于一个给定的数字，第一个得到排序结果的算法就是最快的排序算法。<br>创建UserValidator类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserValidator</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserValidator</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String name, String password)</span></span>&#123;</span><br><span class="line">		Random random = <span class="keyword">new</span> Random();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"Validator %s: Validating a user during %d seconds\n"</span>,<span class="keyword">this</span>.name,duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> random.nextBoolean();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建TaskValidator类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskValidator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> UserValidator validator;</span><br><span class="line">	<span class="keyword">private</span> String user;</span><br><span class="line">	<span class="keyword">private</span> String password;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TaskValidator</span><span class="params">(UserValidator validator,String user, String password)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.validator = validator;</span><br><span class="line">		<span class="keyword">this</span>.user = user;</span><br><span class="line">		<span class="keyword">this</span>.password = password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(!validator.validate(user, password))&#123;</span><br><span class="line">			<span class="comment">//如果用户没有通过UserValidator验证，抛出Exception</span></span><br><span class="line">			System.out.printf(<span class="string">"%s: The user has not been found\n"</span>,validator.getName());</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Error validating user"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"%s: The user has been found\n"</span>,validator.getName());</span><br><span class="line">		<span class="keyword">return</span> validator.getName();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		String username = <span class="string">"test"</span>;</span><br><span class="line">		String password = <span class="string">"test"</span>;</span><br><span class="line"></span><br><span class="line">		UserValidator ldapValidator = <span class="keyword">new</span> UserValidator(<span class="string">"LDAP"</span>);</span><br><span class="line">		UserValidator dbValidator = <span class="keyword">new</span> UserValidator(<span class="string">"DateBase"</span>);</span><br><span class="line"></span><br><span class="line">		TaskValidator ldapTask = <span class="keyword">new</span> TaskValidator(ldapValidator, username, password);</span><br><span class="line"></span><br><span class="line">		TaskValidator dbTask = <span class="keyword">new</span> TaskValidator(dbValidator, username, password);</span><br><span class="line"></span><br><span class="line">		List&lt;TaskValidator&gt; taskList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		taskList.add(ldapTask);</span><br><span class="line">		taskList.add(dbTask);</span><br><span class="line"></span><br><span class="line">		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">		String result;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			result = executor.invokeAny(taskList);</span><br><span class="line">			System.out.printf(<span class="string">"Main: Result: %s\n"</span>,result);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">		System.out.printf(<span class="string">"Main: End of the Execution\n"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>invokeAny()方法接受一个任务类别，然后运行任务，并返回第一个完成任务并且没有抛出异常的任务的执行结果。<br>UserValidator对象，返回随机的boolean值。<br>每个UserValidator对象被TaskValidator对象使用，TaskValidator对象实现了Callable接口。<br>如果UserValidator类的validate()方法返回false，那么TaskValidator类将抛出Exeception异常，否则，返回true。</p>
<ul>
<li>如果两个任务都返回true值，那么invokeAny()方法的结果就是首先完成任务的名称。</li>
<li>如果第一个任务返回true值，第二个任务抛出异常，那么invokeAny()方法的结果就是第一个任务的名称。</li>
<li>如果第一个任务抛出Exception异常，第二个任务返回true值，那么invokeAny()方法的结果就是第二个任务的名称。</li>
<li>如果两个任务都抛出Exception异常，那么invokeAny()方法将抛出ExecutionException异常。<br>ThreadPoolExecutor类还提供了invokeAny()方法的其他版本，invokeAny(Collection&lt;? extends Callable <t> tasks, long timeout, TimeUnit unit):这个方法执行所有的任务，如果在给定的超时期满之前某个任务已经成功完成（也就是未抛出异常），则返回其结果。</t></li>
</ul>
<p><br> <br></p>
<h2 id="运行多个任务并处理所有结果"><a href="#运行多个任务并处理所有结果" class="headerlink" title="运行多个任务并处理所有结果"></a>运行多个任务并处理所有结果</h2><p>执行器框架（Executor Framework）允许执行并发任务不需要考略线程创建和执行。<br>它还提供了可以用来在先执行器中执行任务的状态和获取任务运行结果的Future类。<br>如想等待任务结束，可以使用如下两种方法</p>
<ul>
<li>如果任务执行结束，那么Future接口的isDone()方法返回false，那么TaskValidator类将抛出Exeception异常，否则，返回true。</li>
<li>在调用shutdown()方法后，ThreadPoolExecutor类的awaitTermination()方法会将线程休眠，直到所有的任务执行结束。<br>创建Result类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Result</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.value = value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Result</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Result <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Staring\n"</span>, <span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s: Waiting %d seconds for results.\n"</span>, <span class="keyword">this</span>.name,duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			value += (<span class="keyword">int</span>)(Math.random()*<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		Result result = <span class="keyword">new</span> Result();</span><br><span class="line">		result.setName(<span class="keyword">this</span>.name);</span><br><span class="line">		result.setValue(value);</span><br><span class="line">		System.out.printf(<span class="string">"%s: Ends\n"</span>, <span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">		List&lt;Task&gt; taskList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task-"</span> + i);</span><br><span class="line">			taskList.add(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		List&lt;Future&lt;Result&gt;&gt; resultList = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			resultList = executor.invokeAll(taskList);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Core: Printing the results\n"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; resultList.size(); i++)&#123;</span><br><span class="line">			Future&lt;Result&gt; future = resultList.get(i);</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Result result=future.get();</span><br><span class="line">				System.out.printf(<span class="string">"%s: %s\n"</span>,result.getName(),result.getValue());</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException | ExecutionException)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过invokeAll()方法等待所有任务的完成。<br>这个方法接受一个Callable对象列表，并返回一个Future对象列表。<br>在这个列表中，每个任务对应一个Future对象。Future对象列表中的第一个对象控制Callable列表中第一个任务，以此类推。<br>在存储结构的列表声明中，用在Future接口中的泛型参数的数据类型必须与Callable接口的泛型数据类型从相兼容。<br>使用Future对象仅用来获取任务的结果。当所有的任务执行结束时这个方法也执行结束了，如果在返回的Future对象上调用isDone()方法，那么所有的调用将返回true值。<br><br> <br></p>
<h2 id="在执行器中延时执行任务"><a href="#在执行器中延时执行任务" class="headerlink" title="在执行器中延时执行任务"></a>在执行器中延时执行任务</h2><p>想让任务在过一段时间后才被执行或者任务能够被周期性执行，就得用上ScheduleThreadPoolExecutor类。<br>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Starting at : %sn"</span>, name, <span class="keyword">new</span> Date());</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ScheduledExecutorService executor = (ScheduledExecutorService)Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">		System.out.printf(<span class="string">"Main: Starting at: %sn"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task "</span> + i);</span><br><span class="line">			executor.schedule(task, i + <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">		&#125;</span><br><span class="line">		executor.shutdown();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			executor.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Core: Ends at : %sn"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ScheduleThreadPoolExecutor执行器，schedule()方法接收如下参数：</p>
<ul>
<li>即将执行的任务</li>
<li>任务执行前所要等待的时间</li>
<li>等待时间的单位，由TimeUnit类的一个常量来指定</li>
</ul>
<p>也可以使用Runnable接口来实现任务，因为ScheduledThreadPoolExecutor类的schedule()方法可以同时接受这两种类型的任务。<br>Java推荐仅在开发定时任务程序时采用ScheduleThreadPoolExecutor类。<br>在调用shutdown()时，可以配置ScheduleThreadPoolExecutor的行为，默认是不论执行器是否结束，待处理的任务仍将被执行。<br>可以童工setExecuteExistingDelayedTasksAfterShutdownPolicy()来改变这个行为，传递false，执行shutdown后，待处理的任务将不会被执行。<br><br> <br></p>
<h2 id="在执行器中周期性执行任务"><a href="#在执行器中周期性执行任务" class="headerlink" title="在执行器中周期性执行任务"></a>在执行器中周期性执行任务</h2><p>通过ScheduleThreadPoolExecutor类来执行周期性的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"%s: Executed at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	ScheduledExecutorService executor = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">	System.out.printf(<span class="string">"Main: Starting at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">	Task task = <span class="keyword">new</span> Task(<span class="string">"Task"</span>);</span><br><span class="line">	ScheduledFuture&lt;?&gt; result = executor.scheduleAtFixedRate(task, <span class="number">1</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Main: Delay: %d\n"</span>, result.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			TimeUnit.MILLISECONDS.sleep(<span class="number">500</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	executor.shutdown();</span><br><span class="line">	System.out.printf(<span class="string">"Main: No More tasks at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.printf(<span class="string">"Main: Finished at: %s\n"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>scheduleAtFixedRate()方法发送任务，这个方法接收4个参数</p>
<ul>
<li>被周期性执行的任务</li>
<li>任务第一次执行后的延时时间</li>
<li>两次执行的时间周期</li>
<li>第2个和第3个参数的时间单位<br>两次执行之间的周期是指任务在两次执行开始时的时间间隔。<br>如果有一个周期性的任务需要5秒钟，但是却让它每3秒执行一次，那么，在任务执行的过程中将会有两个任务实例同时存在。</li>
</ul>
<p>ScheduleThreadPoolExecutor类还提供了其他方法来安排周期性任务的运行。比如，scheduleWithFixedRate()方法。这个方法与scheduledAtFixedRate()方法具有相同的参数，但是略有一些不同需要引起注意。在scheduleAtFixedRate()中，第3个参数表示任务两次执行开始时间的间隔，而在scheduledWithFixedDelay()方法中，第3个参数则是表示任务上一次执行结束的时间与任务下一次开始执行的时间间隔。</p>
<p>也可以配置ScheduleThreadPoolExecutor实心shutdown()方法的行为，默认行为是当调用shutdown()方法后，定时任务就结束了。可以通过ScheduleThreadPoolExecutor类的setContinueExistingPeriodicTasksAfterShutdownPolicy()方法来改变这个行为，传递参数true给这个方法，这样shutdown之后，周期性任务仍将继续执行。</p>
<p><br> <br></p>
<h2 id="在执行器中取消任务"><a href="#在执行器中取消任务" class="headerlink" title="在执行器中取消任务"></a>在执行器中取消任务</h2><p>当线程不再需要时就销毁，Futurn接口的cancel()方法来执行取消操作。<br>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			System.out.printf(<span class="string">"Task: Test\n"</span>);</span><br><span class="line">			Thread.sleep(<span class="number">100</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">		Task task = <span class="keyword">new</span> Task();</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Executing the Task\n"</span>);</span><br><span class="line"></span><br><span class="line">		Future&lt;String&gt; result = executor.submit(task);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">2</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Cancelling the Task\n"</span>);</span><br><span class="line">		result.cancel(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Cancelled: %s\n"</span>, result.isCancelled());</span><br><span class="line">		System.out.printf(<span class="string">"Main: Done: %s\n"</span>, result.isDone());</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">		System.out.printf(<span class="string">"Main: The executor has finished\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果想取消一个已经发送给执行器的任务，可以使用Future接口的cancel()方法。<br>根据调用cancel()方法时所传递的参数以及任务的状态，这个方法的行为有些不同。</p>
<ul>
<li>如果任务已经完成，或者之前已经被取消，或者由于某种原因而不能被取消，那么方法将返回false并且任务也不能取消。</li>
<li>如果任务在执行器中等待分配Thread对象来执行它，那么任务呗取消，并且不会开始执行。如果任务已经在运行，那么它依赖于调用cancel()方法时所传递的参数。如果传递的参数是true并且任务正在运行，那么任务将被取消。如果传递的参数为false并且任务正在运行，那么任务不会被取消。</li>
</ul>
<p><br> <br></p>
<h2 id="在执行器中控制任务的完成"><a href="#在执行器中控制任务的完成" class="headerlink" title="在执行器中控制任务的完成"></a>在执行器中控制任务的完成</h2><p>FutureTask类提供了一个名为done()的方法，允许在执行器中的任务执行结束之后，还可以执行一些代码。<br>这个方法可以被用来执行一些后期处理操作，比如：产生报表，通过邮件发送结果或释放一些系统资源。<br>当任务执行完成受FutureTask类控制时，这个方法在内部被FutureTask类调用。在任务结果设置好后以及任务的状态已经变为isDone之后，无论任务是否被取消或者正常结束，done()方法才被调用。<br>默认情况下，done()方法的实现为空，即没有任何具体的代码实现。我们可以覆盖FutureTask类并实现done()方法来改变这种行为。<br>创建ExecutableTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutableTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	 <span class="keyword">private</span> String name;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="title">ExecutableTask</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">this</span>.name = name;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="meta">@Override</span></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	 	<span class="keyword">try</span>&#123;</span><br><span class="line">	 		Long duration = (<span class="keyword">long</span>)(Math.random()*<span class="number">10</span>);</span><br><span class="line">	 		System.out.printf(<span class="string">"%s: Waiting %d seconds for results.n"</span>,<span class="keyword">this</span>.name, duration);</span><br><span class="line">	 		TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">	 	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line"></span><br><span class="line">	 	&#125;</span><br><span class="line">	 	<span class="keyword">return</span> <span class="string">"Hello world. I'm "</span> + name;</span><br><span class="line">	 &#125;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">	 	<span class="keyword">return</span> name;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建ResultTask类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultTask</span> <span class="keyword">extends</span> <span class="title">FutureTask</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ResultTask</span><span class="params">(Callable&lt;String&gt; callable)</span></span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(callable);</span><br><span class="line">		<span class="keyword">this</span>.name = ((ExecutableTask) callable).getName();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(isCancelled())&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%s: Has been cancelled\n"</span>,name);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.printf(<span class="string">"%s: Has finished\n"</span>,name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">		ResultTask resultTasks[] = <span class="keyword">new</span> ResultTask[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span> ;i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">			ExecutableTask executableTask = <span class="keyword">new</span> ExecutableTask(<span class="string">"Task "</span> + i);</span><br><span class="line">			resultTasks[i] = <span class="keyword">new</span> ResultTask(executableTask);</span><br><span class="line">			executor.submit(resultTasks[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resultTasks.length; i++)&#123;</span><br><span class="line">			resultTasks[i].cancel(<span class="keyword">true</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; resultTasks.length; i++)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(!resultTasks[i].isCancelled())&#123;</span><br><span class="line">					System.out.printf(<span class="string">"%s\n"</span>,resultTasks[i].get());</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException | ExecutionException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当任务执行结束时，FutureTask类就会调用done()方法。<br>在创建好返回值以及改变任务 状态为isDone之后，FutureTask类就会在内部调用done()方法。<br>虽然我们无法改变任务的结果值，也无法改变任务的状态，但是可以通过任务来关闭系统资源、输出日志信息、发送通知等。</p>
<p><br> <br></p>
<h2 id="在执行器中分离任务的启动与结果的处理"><a href="#在执行器中分离任务的启动与结果的处理" class="headerlink" title="在执行器中分离任务的启动与结果的处理"></a>在执行器中分离任务的启动与结果的处理</h2><p>如果需要在一个对象里发送任务给执行器，然后在另一个对象里处理结果。对于这种情况，Java并发APi提供了CompletionService类。<br>CompletionService类有一个方法用来发送任务给执行器，还有一个方法为下一个已经执行结束的任务获取Future对象。<br>从内部实现的机制来看，CompletionService类使用Executor对象来执行任务。这个行为的优势是可以共享CompletionService对象，并发送任务到执行器，然后其他的对象可以处理任务的结果。<br>第二个方法有一个不足之处，它只能为已经执行结束的任务获取Future对象，因此，这些Future对象只能被用来获取任务的结果。<br>创建ReportGenerator类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportGenerator</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String sender;</span><br><span class="line">	<span class="keyword">private</span> String title;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReportGenerator</span><span class="params">(String sender, String title)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.sender = sender;</span><br><span class="line">		<span class="keyword">this</span>.title = title;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>) (Math.random() * <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"%s_%s: ReportGenerator: Generating a report during %d seconds\n"</span>,<span class="keyword">this</span>.sender, <span class="keyword">this</span>.title, duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		String ret = sender + <span class="string">": "</span> + title;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建ReportProcessor类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportProcessor</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> CompletionService&lt;String&gt; service;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> end;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReportProcessor</span><span class="params">(CompletionService&lt;String&gt; service)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">		end = <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(!end)&#123;</span><br><span class="line">			<span class="keyword">try</span>&#123;</span><br><span class="line">				Future&lt;String&gt; result = service.poll(<span class="number">20</span>, TimeUnit.SECONDS);</span><br><span class="line">				<span class="keyword">if</span>(result)&#123;</span><br><span class="line">					String report = result.get();</span><br><span class="line">					System.out.printf(<span class="string">"ReportReceiver: Report Recived: %s\n"</span>, report);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;<span class="keyword">catch</span>(ExecutionException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(<span class="keyword">boolean</span> end)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.end = end;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建ReportRequest类,模拟请求获取报告<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportRequest</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> CompletionService&lt;String&gt; service;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ReportRequest</span><span class="params">(String name, CompletionService&lt;String&gt; service)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name; </span><br><span class="line">		<span class="keyword">this</span>.service = service;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		ReportGenerator reportGenerator = <span class="keyword">new</span> ReportGenerator(name, <span class="string">"Report"</span>);</span><br><span class="line">		service.submit(reportGenerator);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();</span><br><span class="line">	CompletionService&lt;String&gt; service = <span class="keyword">new</span> ExecutorCompletionService&lt;&gt;(executor);</span><br><span class="line"></span><br><span class="line">	ReportRequest faceRequest = <span class="keyword">new</span> ReportRequest(<span class="string">"Face"</span>, service);</span><br><span class="line">	ReportRequest onlineRequest = <span class="keyword">new</span> ReportRequest(<span class="string">"Online"</span>, service);</span><br><span class="line">	Thread faceThread = <span class="keyword">new</span> Thread(faceRequest);</span><br><span class="line">	Thread onlineThread = <span class="keyword">new</span> Thread(onlineRequest);</span><br><span class="line"></span><br><span class="line">	ReportProcessor processor = <span class="keyword">new</span> ReportProcessor(service);</span><br><span class="line">	Thread senderThread = <span class="keyword">new</span> Thread(processor);</span><br><span class="line"></span><br><span class="line">	System.out.printf(<span class="string">"Main: Starting the Threads\n"</span>);</span><br><span class="line">	faceThread.start();</span><br><span class="line">	onlineThread.start();</span><br><span class="line">	senderThread.start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Main: Waiting for the report generators.\n"</span>);</span><br><span class="line">		faceThread.join();</span><br><span class="line">		onlineThread.join();</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	System.out.printf(<span class="string">"Main: Shuting down the executor.\n"</span>);</span><br><span class="line">	executor.shutdown();</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		executor.awaitTermination(<span class="number">1</span>, TimeUnit.DAYS);</span><br><span class="line">	&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	processor.setEnd(<span class="keyword">true</span>);</span><br><span class="line">	System.out.printf(<span class="string">"Main: Ends\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CompletionService类可以执行Callable或Runnable类型的任务，由于Runnable对象不能产生结果，因此CompletionService的基本原则不适用与此。<br>CompletionSe类提供了其他两种方法来获取任务已经完成的Future对象。这些方法如下：</p>
<ul>
<li>poll() 无参数的poll()方法用于检查队列中是否有Future对象。如果队列为空，则立即返回null。否则，它将返回队列中的第一个元素，并移除这个元素。</li>
<li>take()这个方法也没有参数，它检查队列中是否有Future对象。如果队列为空，它将阻塞线程直到队列中有可用的元素。如果队列中有元素，它将返回队列中的第一个元素，并移除这个元素。</li>
</ul>
<p><br> <br></p>
<h2 id="处理在执行器中被拒绝的任务"><a href="#处理在执行器中被拒绝的任务" class="headerlink" title="处理在执行器中被拒绝的任务"></a>处理在执行器中被拒绝的任务</h2><p>当我们想结束执行器的执行时，调用shutdown()方法来表示执行器应当结束。<br>但是，执行器只有等待正在运行的任务或者等待执行的任务结束后，才能真正结束。<br>如果在shutdown()方法与执行器结束之间发送一个任务给执行器，这个任务会被拒绝，因为这个时间段执行器已不再接受任务了。ThreadPoolExecutor类提供了一套机制，当任务呗拒绝时调用这套机制来处理它们。<br>创建RejectedTaskController类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RejectedTaskController</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaskController: The task %s has been rejected\n"</span>,r.toString());</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaskController: %s\n"</span>,executor.toString());</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaskController: Terminating: %s\n"</span>,executor.isTerminating());</span><br><span class="line">		System.out.printf(<span class="string">"RejectedTaksController: Terminated: %s\n"</span>,executor.isTerminated());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.printf(<span class="string">"Task %s : Starting\n"</span>, name);</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			Long duration = (<span class="keyword">long</span>)(Math.random()* <span class="number">10</span>);</span><br><span class="line">			System.out.printf(<span class="string">"Task %s: ReportGenerator: Generating a report during %d seconds\n"</span>,name , duration);</span><br><span class="line">			TimeUnit.SECONDS.sleep(duration);</span><br><span class="line">		&#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.printf(<span class="string">"Task %s: Ending\n"</span>, name);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		RejectedTaskController controller = <span class="keyword">new</span> RejectedTaskController();</span><br><span class="line">		ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newCachedThreadPool();</span><br><span class="line">		executor.setRejectedExecutionHandler(controller);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Starting.\n"</span>) ;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">			Task task = <span class="keyword">new</span> Task(<span class="string">"Task"</span> + i);</span><br><span class="line">			executor.submit(task);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Shuting down the Executor.\n"</span>);</span><br><span class="line">		executor.shutdown(); </span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: Sending another Task\n"</span>);</span><br><span class="line">		Task task = <span class="keyword">new</span> Task(<span class="string">"RejectedTask"</span>);</span><br><span class="line">		executor.submit(task);</span><br><span class="line"></span><br><span class="line">		System.out.printf(<span class="string">"Main: End.\n"</span>); </span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了处理在执行器中被拒绝的任务，需要创建一个实现RejectedExceptionHandler接口的处理类。这个接口有一个rejectedExecution()方法，其中有两个参数：</p>
<ul>
<li>一个Runnable对象，用来存储被拒绝的任务；</li>
<li>一个Executor对象，用来存储任务被拒绝的执行器。<br>被执行器拒绝的每一个任务都将调用这个方法。需要先调用Executor类的setRejectedExecutionHandle()方法来设置用于被拒绝的任务的处理程序。<br>当执行器接收一个任务并开始执行时，它先检查shutdown()方法是否已经被调用了。如果是，那么执行器就拒绝这个任务。首先，执行器会寻找通过setRejectedExecutionHandler()方法设置的用于被拒绝的任务的处理程序，如果找到一个处理程序，执行器就调用其rejectedExecution()方法：否则就抛出RejectedExecutionExeception异常。这是一个运行时异常，因此并不需要catch语句来对其进行处理。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/05/13/一步一步精通Java多线程4/" data-id="cius4sg2l000ei4gft9rx1519" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2016/05/27/2016大计划/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          2016大计划
        
      </div>
    </a>
  
  
    <a href="/2016/05/09/一步一步精通Java多线程3/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Java多线程 0x03</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/27/RBAC模型/">RBAC模型</a>
          </li>
        
          <li>
            <a href="/2016/09/16/安全加密认证基础知识/">安全加密认证基础知识</a>
          </li>
        
          <li>
            <a href="/2016/09/13/RX前传/">RX前传</a>
          </li>
        
          <li>
            <a href="/2016/08/08/源码分析OKHttp/">源码分析OKHttp</a>
          </li>
        
          <li>
            <a href="/2016/08/05/doc-ppt-online/">在线预览ppt doc</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Jimmy Yao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>