<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Jimmy的日记</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录我职业生涯的点点滴滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Jimmy的日记">
<meta property="og:url" content="http://JimmyYao984.github.io/index.html">
<meta property="og:site_name" content="Jimmy的日记">
<meta property="og:description" content="记录我职业生涯的点点滴滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Jimmy的日记">
<meta name="twitter:description" content="记录我职业生涯的点点滴滴">
  
    <link rel="alternate" href="/atom.xml" title="Jimmy的日记" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jimmy的日记</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">study new skill step by step</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://JimmyYao984.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-RBAC模型" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/10/27/RBAC模型/" class="article-date">
  <time datetime="2016-10-27T08:50:48.000Z" itemprop="datePublished">2016-10-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/10/27/RBAC模型/">RBAC模型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>RBAC支持三个著名的安全原则：最小权限原则、 责任分离原则和数据抽象原则。</p>
<ul>
<li>最小权限原则之所以被RBAC所支持，是因为RBAC可以将其角色配置成其完成任务所需要的最小的权限集。</li>
<li>责任分离原则可以通过调用相互独立互斥的角色来共同完成敏感的任务二体现，比如要求一个记账员和财务管理员共同过账</li>
<li>数据抽象可以通过权限的抽象来体现，如财务操作用借款、存款等抽象权限，而不用操作系统提供的典型读、写、执行权限。然而这些原则必须通过RBAC各部件的详细配置才能得以体现。<br>RBAC认为权限授权的实际上是WHO、WHAT、HOW的问题。</li>
<li>WHO 权限的拥有者或主体(如Principal  User Role Actor)</li>
<li>WHAT 权限针对的对象或资源（Resource Class）</li>
<li>HOW 具体的权限（Privilege，正向授权与负向授权）</li>
<li>Operator 操作,也就是Privilege+Resource</li>
<li>Role 角色，一定数量的权限的集合。权限分配的单位与载体，目的是隔离User与Privilege的逻辑关系</li>
<li>Group 用户组，权限分配的单位与载体。权限不考虑分配给特定的用户而给组。组可以包括组，也可以包含用户，组内用户继承组的权限。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/10/27/RBAC模型/" data-id="cius4sg1t0003i4gfd8i85bmn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-安全加密认证基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/16/安全加密认证基础知识/" class="article-date">
  <time datetime="2016-09-16T09:04:46.000Z" itemprop="datePublished">2016-09-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/16/安全加密认证基础知识/">安全加密认证基础知识</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="安全概述"><a href="#安全概述" class="headerlink" title="安全概述"></a>安全概述</h2><p>在典型的场景中，安全主要用于解决4类需求：</p>
<ul>
<li>保密(Security/Confidentiality)</li>
<li>鉴别/认证(Authentication)</li>
<li>完整性(Integrity)</li>
<li>不可否认性(non-repudiation)</li>
</ul>
<h2 id="对称加密概述"><a href="#对称加密概述" class="headerlink" title="对称加密概述"></a>对称加密概述</h2><p>密钥：分为加密密钥和解密密钥<br>明文：没有进行加密，能够直接代表原文含义的信息<br>密文：经过加密处理之后，隐藏原文含义的信息<br>加密：将明文转换成密文的实施过程<br>解密：将密文转换成明文的实施过程<br><img src="http://7xvn7e.com1.z0.glb.clouddn.com/201609161717.png" alt="Mark-Down"></p>
<p>对称还是非对称，只是K与K’是否相等</p>
<h3 id="加密的方式"><a href="#加密的方式" class="headerlink" title="加密的方式"></a>加密的方式</h3><ul>
<li>置换加密</li>
<li>转置加密</li>
<li>乘积加密<br>置换加密：原文的字母替换成一个另一个字母， 如：原文：abc 密文：xyz<br>转置加密：字母还是那些字母，位置交换，如：abc 密文：cab<br>乘积加密：置换加密和转置加密的乘积：如：abc 密文：zxy</li>
</ul>
<h2 id="非对称加密（公钥密码）概述"><a href="#非对称加密（公钥密码）概述" class="headerlink" title="非对称加密（公钥密码）概述"></a>非对称加密（公钥密码）概述</h2><p>公钥和密钥都有一个产生，公钥公开，私钥保密。<br>公开密钥的算法的最重要两大数学基础：</p>
<ul>
<li>建立在分解大数的困难度</li>
<li>建立在以大素数为模来计算离散对数的困难度</li>
</ul>
<h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><p>建立在分解大数的困难度<br>公钥/私钥长度 至少1024bit</p>
<h2 id="密钥交换概述"><a href="#密钥交换概述" class="headerlink" title="密钥交换概述"></a>密钥交换概述</h2><p>对称加密的特点</p>
<ul>
<li>高效</li>
<li>密钥交换的问题</li>
<li>不如RSA的加密安全程度高，但是当选择256bit的AES，仍然能够胜任绝大多数的安全领域</li>
</ul>
<p>非对称加密的特点</p>
<ul>
<li>安全性足够高</li>
<li>没有密钥交换的问题</li>
<li>效率低，对于大数据加密很慢</li>
</ul>
<p>实际的保密会话应用场景</p>
<ul>
<li>基于高效的对称加密算法对会话进行加密（AES,256Bit Shared Key）</li>
<li>会话密钥实时产生且周期性变化</li>
<li>基于其他足够安全的方式进行会话密钥的传输和交换</li>
</ul>
<p>利用公钥密码来交换会话密钥</p>
<ul>
<li>实时随机的会话密钥产生</li>
<li>使用对端的公钥对产生的会话密钥加密并传递给对端</li>
<li>对端使用私钥解密获取会话密钥</li>
<li>双方开始基于共享多线程会话密钥进行对称加密的保密会话同性</li>
</ul>
<p>Diffie-Hellman密钥交换协议</p>
<ul>
<li>基于以大素数为模计算离散对数的困难度</li>
<li>双方各自选定Key，然后以一定算法变换（使得key不以明文传输）后传输给对方</li>
<li>双方利用对方交换来的数据和自己选定的key做变换，获得一个一致的结果，作为会话密钥</li>
</ul>
<h4 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h4><p>Hash（散列）函数（算法）的定义是：变长的输入变换成定长的输出。<br>常见的Hash算法：MD5（128bit） 、 SHA1（160bit）<br>Hash的特点：</p>
<ul>
<li>易变性：即便原始信息发生1bit的变化，Hash的输出将会有不可预知的巨大变化</li>
<li>不可逆：通过hash结果构造出满足的输入信息是不可能的或者及其困难的。<br>实例：<br>*文件下载时的MD5</li>
<li>消息传送时尾部额外传MD</li>
<li>CRC校验的作用和不足</li>
<li>MD检验消息恶劣环境传输的完整性和未受损坏</li>
<li>应用程序中对于核心文件/数据库读写的鲁棒性保护，防止掉电和Crash</li>
</ul>
<h3 id="HMAC-（Hash-based-Message-Authentication-Code）"><a href="#HMAC-（Hash-based-Message-Authentication-Code）" class="headerlink" title="HMAC （Hash-based Message Authentication Code）"></a>HMAC （Hash-based Message Authentication Code）</h3><p>遇到的问题：<br>直接尾部附带消息摘要的问题（篡改内容的同时篡改摘要）<br>直接对密码做Hash传输的认证的问题（重放攻击）<br>HMAC如何解决这个问题：<br>HMAC就是使用Key对原始消息变换后再进行HASH</p>
<h2 id="电子签名"><a href="#电子签名" class="headerlink" title="电子签名"></a>电子签名</h2><p>RSA利用私钥签名</p>
<h4 id="HASH-公钥密码术：成就电子签名"><a href="#HASH-公钥密码术：成就电子签名" class="headerlink" title="HASH+公钥密码术：成就电子签名"></a>HASH+公钥密码术：成就电子签名</h4><ul>
<li>RSA的低效率特性，导致即便是签名也不适合直接对原始信息进行签名</li>
<li>利用HASH先完成消息摘要和完整性鉴别的作用</li>
<li>而后对简单的消息摘要进行基于公钥密码术的签名</li>
<li>签名一般附着于原始消息尾部或者头部一起发送</li>
</ul>
<h2 id="数字证书和PKI"><a href="#数字证书和PKI" class="headerlink" title="数字证书和PKI"></a>数字证书和PKI</h2><p>公钥作为一个字段存储于数字证书中<br>证书的交换和传输即可传输/交换公钥<br>利用签名来保护数字证书本身<br>数字时代的信任关系： 一个受信任的证书列表</p>
<h3 id="证书链和PKI"><a href="#证书链和PKI" class="headerlink" title="证书链和PKI"></a>证书链和PKI</h3><p>人的信任链： 孔子-&gt;孔子的徒弟-&gt;孔子徒弟的徒弟<br>数字时代的信任链：证书链<br>证书签名的不同点：根证书自签名，非根证书父签名<br>证书的限制：</p>
<ul>
<li>约束</li>
<li>用途</li>
<li>有效期</li>
</ul>
<p>基于可信任证书的认证方式被广泛的应用在现代安全领域，比如：WIFI、HTTPS<br>在HTTPS中，典型的Client对Server的认证和鉴别基于可信任列表</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/09/16/安全加密认证基础知识/" data-id="cius4sg32000hi4gfqspafv0k" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-RX前传" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/09/13/RX前传/" class="article-date">
  <time datetime="2016-09-13T06:03:22.000Z" itemprop="datePublished">2016-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/09/13/RX前传/">RX前传</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><p>根据给定的查询请求搜索到整个互联网上的猫的图片。每个图片包含可爱指数的参数。<br>我们的任务将会下载到一个猫的列表集合，选择最可爱的那个，然后把它保存到本地。</p>
<h4 id="模型和API"><a href="#模型和API" class="headerlink" title="模型和API"></a>模型和API</h4><p>猫的结构数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt;</span>&#123;</span><br><span class="line">	Bitmap images;</span><br><span class="line">	<span class="keyword">int</span> cuteness;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Cat another)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Integer.compare(cuteness, another.cuteness);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>阻塞式API<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">	<span class="function">List&lt;Cat&gt; <span class="title">queryCats</span><span class="params">(String query)</span></span>;</span><br><span class="line">	<span class="function">Uri <span class="title">store</span><span class="params">(Cat cat)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>业务逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatHelper</span></span>&#123;</span><br><span class="line">	Api api;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Uri <span class="title">saveTheCutestCat</span><span class="params">(String query)</span></span>&#123;</span><br><span class="line">		List&lt;cat&gt; cats = api.queryCats(query);</span><br><span class="line">		Cat cutest = findCutest(cats);</span><br><span class="line">		Uri savedUri = api.store(cutest);</span><br><span class="line">		<span class="keyword">return</span> savedUri;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主方法savetheCutestCat只包含了3个其他方法， 提供了输入参数然后就能得到结果返回了，<br>在这个方法工作的时候我们需要等待它的完成。</p>
<h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><h5 id="组合：根据其他３个方法而新创建一个方法-saveTheCutestCat-因此组合了它们。"><a href="#组合：根据其他３个方法而新创建一个方法-saveTheCutestCat-因此组合了它们。" class="headerlink" title="组合：根据其他３个方法而新创建一个方法(saveTheCutestCat),因此组合了它们。"></a>组合：根据其他３个方法而新创建一个方法(saveTheCutestCat),因此组合了它们。</h5><h5 id="错误的传递：另外一个好处就是我们处理错误的方式，任何一个方法都可能因执行时发生错误而被终止，这个错误能在任何层次上被处理掉，Java中我们叫它抛异常。我们不需要为组合方法里的每个方法都做异常处理，仅需要对这些组合起来的方法做统一处理"><a href="#错误的传递：另外一个好处就是我们处理错误的方式，任何一个方法都可能因执行时发生错误而被终止，这个错误能在任何层次上被处理掉，Java中我们叫它抛异常。我们不需要为组合方法里的每个方法都做异常处理，仅需要对这些组合起来的方法做统一处理" class="headerlink" title="错误的传递：另外一个好处就是我们处理错误的方式，任何一个方法都可能因执行时发生错误而被终止，这个错误能在任何层次上被处理掉，Java中我们叫它抛异常。我们不需要为组合方法里的每个方法都做异常处理，仅需要对这些组合起来的方法做统一处理"></a>错误的传递：另外一个好处就是我们处理错误的方式，任何一个方法都可能因执行时发生错误而被终止，这个错误能在任何层次上被处理掉，Java中我们叫它抛异常。我们不需要为组合方法里的每个方法都做异常处理，仅需要对这些组合起来的方法做统一处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	List&lt;Cat&gt; cats = api.queryCats(query);</span><br><span class="line">	Cat cutest = findCutest(cats);</span><br><span class="line">	Uri savedUri = api.store(cutest);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">	<span class="keyword">return</span> someDefaultValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br> <br> <br></p>
<h2 id="走向异步"><a href="#走向异步" class="headerlink" title="走向异步"></a>走向异步</h2><h4 id="异步的网络调用"><a href="#异步的网络调用" class="headerlink" title="异步的网络调用"></a>异步的网络调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">CatsQueryCallback</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onCatListReceived</span><span class="params">(List&lt;Cat&gt; cats)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">queryCats</span><span class="params">(String query,CatsQueryCallback catsQueryCallback)</span></span>;</span><br><span class="line">	<span class="function">Uri <span class="title">store</span><span class="params">(Cat cat)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异步的获取猫的信息集合列表，返回正确或错误的结果时都会通过CatsQueryCallback回调接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss CatsHelper&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CutestCatCallback</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onCutestCatSaved</span><span class="params">(Uri uri)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onQueryFailed</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Api api;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTheCutestCat</span><span class="params">(String query, CutestCatCallback cutestCatCallback)</span></span>&#123;</span><br><span class="line">		api.queryCats(query, <span class="keyword">new</span> Api.CatsQueryCallback()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCatListReceived</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">				Cat cutest = findCutest(cats);</span><br><span class="line">				Uri savedUri = api.store(cutest);</span><br><span class="line">				cutestCatCallback.onCutestCatSaved(savedUri);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryFailed</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">				cutestCatCallback.onError(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>两个Api方法都调用异步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Api</span></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">CatsQueryCallback</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onCatListReceived</span><span class="params">(List&lt;Cat&gt; cats)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onQueryFailed</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">StoreCallback</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onCatStored</span><span class="params">(Uri uri)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onStoreFailed</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">queryCats</span><span class="params">(String query, CatsQueryCallback catsQueryCallback)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">(Cat cat, StoreCallback storeCallback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>helper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CutestCatCallback</span></span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onCutestCatSaved</span><span class="params">(Uri uri)</span></span>;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	Api api;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTheCutestCat</span><span class="params">(String query, CutestCatCallback cutestCatCallback)</span></span>&#123;</span><br><span class="line">		api.queryCats(query, <span class="keyword">new</span> Api.CatsQueryCallback()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCatListReceived</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">				Cat cutest = findCutest(cats);</span><br><span class="line">				api.store(cutest, <span class="keyword">new</span> Api.StoreCallback()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCatStored</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">						cutestCatCallback.onCutestCatSaved(uri);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStoreFailed</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						cutestCatCallback.onCutestCatSaved(uri);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryFailed</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">				cutestCatCallback.onError(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br> <br> <br></p>
<h2 id="泛型回调"><a href="#泛型回调" class="headerlink" title="泛型回调"></a>泛型回调</h2><p>从回调接口中找到共同的模式：</p>
<ul>
<li>都有一个分发结果的方法(onCutestCatSaved, onCatListReceived, onCatStored)</li>
<li>它们中大多数有一个用于错误处理的方法(onError, onQueryFailed, onStoreFailed)<br>所以可以创建一个泛型回调接口去代替原来所有的接口。<br>但是不能去改变API的调用方法的签名，必须用创建包装类来间接调用。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onResult</span><span class="params">(T result)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>ApiWrapper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiWrapper</span></span>&#123;</span><br><span class="line">	Api api;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryCats</span><span class="params">(String query, Callback&lt;List&lt;Cat&gt;&gt; catsCallback)</span></span>&#123;</span><br><span class="line">		api.queryCats(query, <span class="keyword">new</span> Api.CatsQueryCallback()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCatListReceived</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">				catsCallback.onResult(cats);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryFailed</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">				catsCallback.onError(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(Cat cat, Callback&lt;Uri&gt; uriCallback)</span></span>&#123;</span><br><span class="line">		api.store(cat, <span class="keyword">new</span> Api.StoreCallback()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCatStored</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">				uriCallback.onResult(uri);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStoreFailed</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">				uriCallback.onError(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CatsHelper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span></span>&#123;</span><br><span class="line">	ApiWrapper apiWrapper;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveTheCutestCat</span><span class="params">(String query, Callback&lt;Uri&gt; cutestCatCallback)</span></span>&#123;</span><br><span class="line">		apiWrapper.queryCats(query, <span class="keyword">new</span> Callback&lt;List&lt;Cat&gt;&gt; ())&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">				Cat cutest = findCutest(cats);</span><br><span class="line">				apiWrapper.store(cutest, cutestCatCallback);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">				cutestCatCallback.onError(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h2 id="做的更好"><a href="#做的更好" class="headerlink" title="做的更好"></a>做的更好</h2><p>如果在异步操作中返回一些临时对象，需要定义一个出来。<br>这样的一个对象需要包括常见的行为（以回调为单一参数），定义这样的类给所有的异步操作使用，这个类叫它AsyncJob。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncJob</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;T&gt; callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更改包装API的调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiWrapper</span></span>&#123;</span><br><span class="line">	Api api;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> AsyncJob&lt;List&lt;Cat&gt;&gt; queryCats(String query)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AsyncJob&lt;List&lt;Cat&gt;&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;List&lt;Cat&gt;&gt; catsCallback)</span></span>&#123;</span><br><span class="line">				api.queryCats(query, <span class="keyword">new</span> Api.CatsQueryCallback()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCatListReceived</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">						catsCallback.onResult(cats);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onQueryFailed</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						catsCallback.onError(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">store</span><span class="params">(Cat cat)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AsyncJob&lt;Uri&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;Uri&gt; uriCallback)</span></span>&#123;</span><br><span class="line">				api.store(cat, <span class="keyword">new</span> Api.StoreCallback()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCatStored</span><span class="params">(Uri uri)</span></span>&#123;</span><br><span class="line">						uriCallback.onResult(uri);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStoreFailed</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						uriCallback.onError(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>CatsHelper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span></span>&#123;</span><br><span class="line">	ApiWrapper apiWrapper;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">saveTheCutestCat</span><span class="params">(String query)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AsyncJob&lt;Uri&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;Uri&gt; cutestCatCallback)</span></span>&#123;</span><br><span class="line">				apiWrapper.queryCats(query)</span><br><span class="line">					.start(<span class="keyword">new</span> Callback&lt;List&lt;Cat&gt;&gt;())&#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">							Cat cutest = findCutest(cats);</span><br><span class="line">							apiWrapper.store(cutest)</span><br><span class="line">								.start(<span class="keyword">new</span> Callback&lt;Uri&gt;()&#123;</span><br><span class="line">									<span class="meta">@Override</span></span><br><span class="line">									<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Uri result)</span></span>&#123;</span><br><span class="line">										cutestCatCallback.onResult(result);</span><br><span class="line">									&#125;</span><br><span class="line">									</span><br><span class="line">									<span class="meta">@Override</span></span><br><span class="line">									<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">										cutestCatCallback.onError(e);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;);</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">							cutestCatCallback.onError(e);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在可以给客户端返回“组合”操作的AsyncJob<ur>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span></span>&#123;</span><br><span class="line">	ApiWrapper apiWrapper;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">saveTheCutestCat</span><span class="params">(String query)</span></span>&#123;</span><br><span class="line">		AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query);</span><br><span class="line">		AsyncJob&lt;Cat&gt; catsListAsyncJob = <span class="keyword">new</span> AsyncJob&lt;Cat&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;Cat&gt; callback)</span></span>&#123;</span><br><span class="line">				catsListAsyncJob.start(<span class="keyword">new</span> Callback&lt;List&lt;Cat&gt;&gt;())&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(List&lt;Cat&gt; result)</span></span>&#123;</span><br><span class="line">						callback.onResult(findCutest(result));</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						callback.onError(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">				</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;;</span><br><span class="line">		</span><br><span class="line">		AsyncJob&lt;Uri&gt; storedUriAsyncJob = <span class="keyword">new</span> AsyncJob&lt;Uri&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;Uri&gt; cutestCatCallback)</span></span>&#123;</span><br><span class="line">				cutestCatAsyncJob.start(<span class="keyword">new</span> Callback&lt;Cat&gt;()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Cat cutest)</span></span>&#123;</span><br><span class="line">						apiWrapper.store(cutest)</span><br><span class="line">						.start(<span class="keyword">new</span> Callback&lt;Uri&gt;()&#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Uri result)</span></span>&#123;</span><br><span class="line">								cutestCatCallback.onResult(result);</span><br><span class="line">							&#125;</span><br><span class="line">							</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">								cutestCatCallback.onError(e);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						cutestCatCallback.onError(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> storedUriAsyncJob;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></ur></p>
<p>AsyncJob<cat> cutestCatAsyncJob<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">AsyncJob&lt;Cat&gt; cutestCatAsyncJob = <span class="keyword">new</span> AsyncJob&lt;Cat&gt;()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;Cat&gt; callback)</span></span>&#123;</span><br><span class="line">		catsListAsyncJob.start(<span class="keyword">new</span> Callback&lt;List&lt;Cat&gt;&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(List&lt;Cat&gt; result)</span></span>&#123;</span><br><span class="line">				callback.onResult(findCutest(result));</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">				callback.onError(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></cat></p>
<p>这16行代码只有一行有用（对于逻辑来说）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findCutest(result);</span><br></pre></td></tr></table></figure></p>
<p>剩下的仅仅是开启另外一个AsyncJob和传递结果与错误的样板代码。</p>
<h4 id="该怎么写？必须做下面两件事情"><a href="#该怎么写？必须做下面两件事情" class="headerlink" title="该怎么写？必须做下面两件事情:"></a>该怎么写？必须做下面两件事情:</h4><ul>
<li>AsyncJob是我们转换的结果</li>
<li>转换方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function">R <span class="title">call</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>相当简单，Func接口有两个类型成员，T对应于参数类型而R对应于返回类型。<br>当从一个AsyncJob中装换处结果后就需要做一些值之间的映射，这样的方法叫map。<br>定义这个方法实例（Func类型）最好的地方就在AsyncJob类中，所以AsyncJob代码里看起来就是这样了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncJob</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;T&gt; callback)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> &lt;R&gt; <span class="function">AsyncJob&lt;R&gt; <span class="title">map</span><span class="params">(Func&lt;T, R&gt; func)</span></span>&#123;</span><br><span class="line">		<span class="keyword">final</span> AsyncJob&lt;T&gt; source = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AsyncJob&lt;R&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;R&gt; callback)</span></span>&#123;</span><br><span class="line">				source.start(<span class="keyword">new</span> Callback&lt;T&gt;()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(T result)</span></span>&#123;</span><br><span class="line">						R mapped = func.call(result);</span><br><span class="line">						callback.onResult(mapped);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						callback.onError(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这时CatsHelper就是下面这样了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span></span>&#123;</span><br><span class="line">	ApiWrapper apiWrapper;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">saveTheCutestCat</span><span class="params">(String query)</span></span>&#123;</span><br><span class="line">		AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query);</span><br><span class="line">		AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(<span class="keyword">new</span> Func&lt;List&lt;Cat&gt;, Cat&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Cat <span class="title">call</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> findCutest(cats);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		AsyncJob&lt;Uri&gt; storedUriAsyncJob = cutestCatAsyncJob.flatMap(<span class="keyword">new</span> Func&lt;Cat, AsyncJob&lt;Uri&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;Uri&gt; cutestCatCallback)</span></span>&#123;</span><br><span class="line">				cutestCatAsyncJob.start(<span class="keyword">new</span> Callback&lt;Cat&gt;()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Cat cutest)</span></span>&#123;</span><br><span class="line">						apiWrapper.store(cutest)</span><br><span class="line">						.start(<span class="keyword">new</span> Callback&lt;Uri&gt;()&#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Uri result)</span></span>&#123;</span><br><span class="line">								cutestCatCallback.onResult(result);</span><br><span class="line">							&#125;</span><br><span class="line">							</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">								cutestCatCallback.onError(e);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						cutestCatCallback.onError(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">				</span><br><span class="line">			<span class="keyword">return</span> storedUriAsyncJob;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br><br><br></p>
<h2 id="高级映射"><a href="#高级映射" class="headerlink" title="高级映射"></a>高级映射</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    ApiWrapper apiWrapper;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">saveTheCutestCat</span><span class="params">(String query)</span> </span>&#123;</span><br><span class="line">        AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query);</span><br><span class="line">        AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(<span class="keyword">new</span> Func&lt;List&lt;Cat&gt;, Cat&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Cat <span class="title">call</span><span class="params">(List&lt;Cat&gt; cats)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> findCutest(cats);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"> </span><br><span class="line">        AsyncJob&lt;Uri&gt; storedUriAsyncJob = cutestCatAsyncJob.map(<span class="keyword">new</span> Func&lt;Cat, Uri&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Uri <span class="title">call</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> apiWrapper.store(cat);</span><br><span class="line">        <span class="comment">//      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ will not compile</span></span><br><span class="line">        <span class="comment">//      Incompatible types:</span></span><br><span class="line">        <span class="comment">//      Required: Uri</span></span><br><span class="line">        <span class="comment">//      Found: AsyncJob&lt;Uri&gt;                </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> storedUriAsyncJob;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ApiWrapper apiWrapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">saveTheCutestCat</span><span class="params">(String query)</span> </span>&#123;</span><br><span class="line">        AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query);</span><br><span class="line">        AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(<span class="keyword">new</span> Func&lt;List&lt;Cat&gt;, Cat&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Cat <span class="title">call</span><span class="params">(List&lt;Cat&gt; cats)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> findCutest(cats);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        AsyncJob&lt;AsyncJob&lt;Uri&gt;&gt; storedUriAsyncJob = cutestCatAsyncJob.map(<span class="keyword">new</span> Func&lt;Cat, AsyncJob&lt;Uri&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">call</span><span class="params">(Cat cat)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> apiWrapper.store(cat);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> storedUriAsyncJob;</span><br><span class="line">        <span class="comment">//^^^^^^^^^^^^^^^^^^^^^^^ will not compile</span></span><br><span class="line">        <span class="comment">//      Incompatible types:</span></span><br><span class="line">        <span class="comment">//      Required: AsyncJob&lt;Uri&gt;</span></span><br><span class="line">        <span class="comment">//      Found: AsyncJob&lt;AsyncJob&lt;Uri&gt;&gt;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在目前这点上我们只能有AsyncJob<asyncjob<uri>&gt;。我们需要往更深处挖吗？我们希望的是，去把AsyncJob在一个级别上的两个异步操作扁平化成一个单一的异步操作。</asyncjob<uri></p>
<p>现在我们需要的是得到能使方法返回映射成R类型也是AsyncJob<r>类型的操作。这个操作应该像map，但在最后应该flatten我们嵌套的AsyncJob。我们叫它为flatMap<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncJob</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;T&gt; callback)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> &lt;R&gt; <span class="function">AsyncJob&lt;R&gt; <span class="title">map</span><span class="params">(Func&lt;T,R&gt; func)</span></span>&#123;</span><br><span class="line">		<span class="keyword">final</span> AysncJob&lt;T&gt; source = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AsyncJob&lt;R&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;R&gt; callback)</span></span>&#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;R&gt; callback)</span></span>&#123;</span><br><span class="line">					source.start(<span class="keyword">new</span> Callback&lt;T&gt;()&#123;</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(T result)</span></span>&#123;</span><br><span class="line">							R mapped = func.call(result);</span><br><span class="line">							callback.onResult(mapped);</span><br><span class="line">						&#125;</span><br><span class="line">						</span><br><span class="line">						<span class="meta">@Override</span></span><br><span class="line">						<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">							callback.onError(e);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> &lt;R&gt; <span class="function">AsyncJob&lt;R&gt; <span class="title">flatMap</span><span class="params">(Func&lt;T,AsyncJob&lt;R&gt;&gt; func)</span></span>&#123;</span><br><span class="line">		<span class="keyword">final</span> AsyncJob&lt;T&gt; source = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> AsyncJob&lt;R&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Callback&lt;R&gt; callback)</span></span>&#123;</span><br><span class="line">				source.start(<span class="keyword">new</span> Callback&lt;T&gt;()&#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(T result)</span></span>&#123;</span><br><span class="line">						AsyncJob&lt;R&gt; mapped = func.call(result);</span><br><span class="line">						mapped.start(<span class="keyword">new</span> Callback&lt;R&gt;()&#123;</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(R result)</span></span>&#123;</span><br><span class="line">								callback.onResult(result);</span><br><span class="line">							&#125;</span><br><span class="line">							</span><br><span class="line">							<span class="meta">@Override</span></span><br><span class="line">							<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">								callback.onError(e);</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;);</span><br><span class="line">					&#125;</span><br><span class="line">					</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Exception e)</span></span>&#123;</span><br><span class="line">						callback.onError(e);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></r></p>
<p>修复CatsHelper<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span></span>&#123;</span><br><span class="line">	ApiWrapper apiWrapper;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">saveTheCutestCat</span><span class="params">(String query)</span></span>&#123;</span><br><span class="line">		AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query);</span><br><span class="line">		AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(<span class="keyword">new</span> Func&lt;List&lt;Cat&gt;, Cat&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> Cat <span class="title">call</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> findCutest(cats);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		AsyncJob&lt;Uri&gt; storeUriAsyncJob = cutestCatAsyncJob.flatMap(<span class="keyword">new</span> Func&lt;Cat, AsyncJob&lt;Uri&gt;&gt;()&#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">call</span><span class="params">(Cat cat)</span></span>&#123;</span><br><span class="line">				<span class="keyword">return</span> apiWrapper.store(cat);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> storedUriAsyncJob;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><br> <br> <br></p>
<h2 id="最后的要点"><a href="#最后的要点" class="headerlink" title="最后的要点"></a>最后的要点</h2><p>如果使用Java 8的lambda表达式，代码会更加简洁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span></span>&#123;</span><br><span class="line">	ApiWrapper apiWrapper;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> AsyncJob&lt;Uri&gt; <span class="title">saveTheCutestCat</span><span class="params">(String query)</span></span>&#123;</span><br><span class="line">		AsyncJob&lt;List&lt;Cat&gt;&gt; catsListAsyncJob = apiWrapper.queryCats(query);</span><br><span class="line">		AsyncJob&lt;Cat&gt; cutestCatAsyncJob = catsListAsyncJob.map(cats-&gt;findCutest(cats));</span><br><span class="line">		AsyncJob&lt;Uri&gt; storedUriAsyncJob = cutestCatAsyncJob.flatMap(cat-&gt;apiWrapper.store(cat));</span><br><span class="line">		<span class="keyword">return</span> storedUriAsyncJob;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CatsHelper</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    Api api;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Uri <span class="title">saveTheCutestCat</span><span class="params">(String query)</span></span>&#123;</span><br><span class="line">        List&lt;Cat&gt; cats = api.queryCats(query);</span><br><span class="line">        Cat cutest = findCutest(cats);</span><br><span class="line">        Uri savedUri = api.store(cutest);</span><br><span class="line">        <span class="keyword">return</span> savedUri;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> Cat <span class="title">findCutest</span><span class="params">(List&lt;Cat&gt; cats)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.max(cats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/09/13/RX前传/" data-id="cius4sg1y0006i4gferxb2xp5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-源码分析OKHttp" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/08/源码分析OKHttp/" class="article-date">
  <time datetime="2016-08-08T06:44:10.000Z" itemprop="datePublished">2016-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/08/源码分析OKHttp/">源码分析OKHttp</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="OkHttp3特点"><a href="#OkHttp3特点" class="headerlink" title="OkHttp3特点"></a>OkHttp3特点</h2><p>OkHttp是一个高效的Http客户端，有如下的特点：</p>
<ul>
<li>支持HTTP2/SPDY</li>
<li>socket自动选择最好路线，并支持自动重连</li>
<li>拥有自动维护的socket连接池，减少握手次数</li>
<li>拥有队列线程池，轻松写并发</li>
<li>拥有Interceptors轻松处理请求与响应（比如透明GZIP压缩，LOGGING）</li>
<li>基于Headers的缓存策略</li>
</ul>
<h4 id="主要对象"><a href="#主要对象" class="headerlink" title="主要对象"></a>主要对象</h4><ul>
<li>Connections:对JDK中socket进行了引用计数封装，用来控制socket连接</li>
<li>Streams：维护HTTP的流，用来对Request/Response进行IO操作</li>
<li>Calls：HTTP请求任务封装</li>
<li>StreamAllocation：用来控制Connections/Streams的资源分配与释放</li>
</ul>
<h4 id="工作流程的概述"><a href="#工作流程的概述" class="headerlink" title="工作流程的概述"></a>工作流程的概述</h4><p>当我们OkHttpClient.newCall(request)进行execute/enenqueue时，实际是将请求Call放到了Dispatcher中，<br>OkHttp使用Dispatcher进行线程分发，它有两种方法，<br>一个是普通的同步单线程；<br>另一个是使用了队列进行并发任务的分发（Dispatch）与回调。</p>
<h4 id="1-Dispatcher的结构"><a href="#1-Dispatcher的结构" class="headerlink" title="1.Dispatcher的结构"></a>1.Dispatcher的结构</h4><p>Dispatcher维护了如下变量，用于控制并发的请求：</p>
<ul>
<li>maxRequests =  64:最大并发请求数为64</li>
<li>maxRequestsPerHost = 5:每个主机最大请求数为5</li>
<li>Dispatcher：分发者，也就是生产者（默认在主线程）</li>
<li>AsyncCall：队列中需要处理的Runnable（包装了异步回调接口）</li>
<li>ExecutorService： 消费者池（也就是线程池）</li>
<li>Deque<readyasynccalls>: 缓存（用数组实现，可自动扩容，无大小限制）</readyasynccalls></li>
<li>Deque<runningasynccalls>: 正在运行的任务，仅仅是用来引用正在运行的任务以判断并发量，注意它并不是消费者缓存</runningasynccalls></li>
</ul>
<p>根据生产者消费者模型的理论，当入队(enqueue)请求时，如果满足(runningRequests &lt; 64 &amp;&amp; runningRequestsPerHost &lt; 5),<br>那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行。<br>如果消费者缓存满了，就放入readyAsyncCalls进行缓存等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">     runningAsyncCalls.add(call);</span><br><span class="line">     executorService().execute(call);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     readyAsyncCalls.add(call);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>当任务执行完成后，调用finished的promoteCalls()函数，手动移动缓存区（可以看出这里是主动清理的，因此不会发生死锁）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Already running max capacity.</span></span><br><span class="line">    <span class="keyword">if</span> (readyAsyncCalls.isEmpty()) <span class="keyword">return</span>; <span class="comment">// No ready calls to promote.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext(); ) &#123;</span><br><span class="line">      AsyncCall call = i.next();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        i.remove();</span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        executorService().execute(call);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>; <span class="comment">// Reached max capacity.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xvn7e.com1.z0.glb.clouddn.com/201608081546.png" alt="Mark-Down"></p>
<h4 id="线程池基础"><a href="#线程池基础" class="headerlink" title="线程池基础"></a>线程池基础</h4><h5 id="线程池好处都有啥"><a href="#线程池好处都有啥" class="headerlink" title="线程池好处都有啥"></a>线程池好处都有啥</h5><p>线程池的关键在于线程复用以减少非核心任务的损耗。<br>线程池技术正是关注如何缩短或调整T1，T3时间的技术，从而提高服务器程序性能的。<br>通过对线程进行缓存，减少了创建销毁的时间损失。<br>通过控制线程数量的阈值，减少了当线程过少时带来的CPU闲置与线程过多时对JVM的内存与线程切换时系统调用的压力。</p>
<h5 id="OkHttp配置的线程池"><a href="#OkHttp配置的线程池" class="headerlink" title="OkHttp配置的线程池"></a>OkHttp配置的线程池</h5><p>在OkHttp，使用如下构造了单例线程例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(executorService == <span class="keyword">null</span>)&#123;</span><br><span class="line">		executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span> , TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),  Util.thread(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> executorService;</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数说明如下：</p>
<ul>
<li>int corePoolSize :最小并发线程数，这里并发同时包括空闲与活动的线程，如果是0的话，空闲一段时间后所有线程将全部被销毁。</li>
<li>int maximumPoolSize：最大线程数，当任务进来时可以扩充的线程最大数，当大于了这个值就会根据丢弃处理机制来处理。<br>long keepAliveTime：当线程数大于corePoolSize时，多余的空闲线程的最大存活时间，类似于HTTP中的keep-alive<br>TimeUnit unit：时间单位，一般用秒<br>BlockingQueue<runnable> workQueue:工作队列<br>ThreadFactory threadFactory：单个线程的工厂，可以打log，设置Dameo（即当JVM退出时，线程自动结束）等。</runnable></li>
</ul>
<p>可以看出，在OkHttp中，构建了一个阈值为[0, Integer.MAX_VALUE]的线程池，它不保留任何最小线程数，随时创建更多的线程数，当线程空闲时只能存活60秒，它使用了一个不存储元素的阻塞工作队列，一个叫做“OkHttp Disptcher”的线程工厂。<br>也就是说，在实际运行中，当收到10个并发请求时，线程池会创建10个线程，当工作完成后，线程池会在60s后相继关闭所有线程。</p>
<h4 id="反向代理模型"><a href="#反向代理模型" class="headerlink" title="反向代理模型"></a>反向代理模型</h4><p>在OkHttp中，使用了与Nginx类似的反向代理与分发技术，这是典型的单生产多消费者问题。<br>我们知道在Nginx站，用户通过HTTP（SOCKET）访问前置的服务器，服务器会添加Header并自动转发给请求给后端群，接着返回数据结果给用户。<br>通过将工作分配给多个后台服务器，可以提高服务的负载均衡能力，实现非阻塞、高并发连接，避免资源全部放到一台服务器而带来的负载、速度、在线率等影响。<br>而在OkHttp中，非常类似于上述场景，它使用Dispatcher作为任务的转发器，线程池对应多台后置服务器，用AsyncCall对应Socket请求，用Deque<readyasynccalls>对应Nginx的内部缓存。</readyasynccalls></p>
<h4 id="OkHttp的任务调度"><a href="#OkHttp的任务调度" class="headerlink" title="OkHttp的任务调度"></a>OkHttp的任务调度</h4><p>当我们希望使用OkHttp的异步请求时，一般进行如下构造<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder().build();</span><br><span class="line">Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">		.url(<span class="string">"http://qq.com"</span>).get().build();</span><br><span class="line">Client.newCall(request).enqueue(<span class="keyword">new</span> Callback()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, IOException e)</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call,Response response)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>当HttpClient的请求入队是，根据代码，我们可以发现实际上是Dispatcher进行了入队操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxReqeustsPerHost)&#123;</span><br><span class="line">		<span class="comment">//添加正在运行的请求</span></span><br><span class="line">		runningAsyncCalls.add(call);</span><br><span class="line">		<span class="comment">//线程池执行请求</span></span><br><span class="line">		executorService().execute(call);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//添加到缓存队列排队等待</span></span><br><span class="line">		readyAsyncCalls.add(call);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果满足条件，那么就直接把AsyncCall直接加到runningCalls的队列中，并在线程池中执行（线程池会根据当前负载自动创建、销毁、缓存相应的线程）。反之就放入readyAsyncCalls进行缓存等待。<br>我们再分析请求元素AsyncCall（它实现了Runnable接口），它内部实现的execute方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">//执行耗时IO任务</span></span><br><span class="line">		Response response = getResponseWithInterceptorChain(forWebSocket);</span><br><span class="line">		<span class="keyword">if</span>(canceled)&#123;</span><br><span class="line">			signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">			<span class="comment">//回调，注意这里回调在线程池中，而不是想当然的在主线程回调</span></span><br><span class="line">			resposneCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Cancelled"</span>));</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">			<span class="comment">//回到，同上</span></span><br><span class="line">			responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">		<span class="keyword">if</span>(signalledCallback)&#123;</span><br><span class="line">			logger.log(Level.INFO, <span class="string">"Callback failure for "</span> + toLoggableString(),e):</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">		<span class="comment">//最关键的代码</span></span><br><span class="line">		client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当任务执行完成后，无论是否有异常，finally代码段总会执行，也就调用Dispatcher的finished函数，打开源码，发现它将正在运行的任务Call从队列runningAsyncCalls中移除后，接着执行promoteCalls()函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">promoteCalls</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//如果目前是最大负荷运转，接着等</span></span><br><span class="line">	<span class="keyword">if</span>(runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>;</span><br><span class="line">	<span class="comment">//如果缓存等待区是空的，接着等</span></span><br><span class="line">	<span class="keyword">if</span>(readyAsyncCall.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(Iterator&lt;AsyncCall&gt; i = readyAsyncCalls.iterator(); i.hasNext();)&#123;</span><br><span class="line">		AsyncCall call = i.next();</span><br><span class="line">		<span class="keyword">if</span>(runningCallsForHost(call) &lt; maxRequestsPerHost)&#123;</span><br><span class="line">			<span class="comment">//将缓存等待区最后一个移动到运行区中，并执行</span></span><br><span class="line">			i.remove();</span><br><span class="line">			runningAsyncCalls.add(call);</span><br><span class="line">			executorService().execute(call);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(runningAsyncCalls.size() &gt;= maxRequests) <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样，就主动的把缓存队列向前走了一步，而没有使用互斥锁等复杂编码。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>OkHttp采用了Dispatcher技术，类似于Nginx，与线程池配合实现了搞并发，低阻塞的运行</li>
<li>OkHttp采用Deque作为缓存，按照入队的顺序先进先出</li>
<li>OkHttp最出彩的地方就是try/finally中调用了finished函数，可以主动控制等待队列的移动，而不是采用锁，极大减少了编码复杂性。<br><br><br><br><br><br><h2 id="Socket管理（StreamAllocation）"><a href="#Socket管理（StreamAllocation）" class="headerlink" title="Socket管理（StreamAllocation）"></a>Socket管理（StreamAllocation）</h2><h4 id="1-选择路线与自动重连-RouteSelector"><a href="#1-选择路线与自动重连-RouteSelector" class="headerlink" title="1.选择路线与自动重连(RouteSelector)"></a>1.选择路线与自动重连(RouteSelector)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Route <span class="title">next</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(!hasNextInetSocketAddress())&#123;</span><br><span class="line">		<span class="keyword">if</span>(!hasNextProxy())&#123;</span><br><span class="line">			<span class="keyword">if</span>(!hasNextPostponed())&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> nextPostponed();</span><br><span class="line">		&#125;</span><br><span class="line">		lastProxy = nextProxy();</span><br><span class="line">	&#125;</span><br><span class="line">	lastInetSocketAddress = nextInetSocketAddress();</span><br><span class="line">	</span><br><span class="line">	Route route = <span class="keyword">new</span>  Route(address, lastProxy, lastInetSocketAddress);</span><br><span class="line">	<span class="keyword">if</span>(routeDatabase.shouldPostpone(route))&#123;</span><br><span class="line">		postponsedRoutes.add(route);</span><br><span class="line">		<span class="keyword">return</span> next();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> route;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如果Proxy为null：</p>
<ol>
<li>在构造函数中设置代理为Proxy.NO_PROXY</li>
<li>如果缓存中的lastInetSocketAddress为空，就通过DNS（默认是Dns.SYSTEM，包装了jdk自带的lookup函数）查询，并保存结果，注意结果是数组，即一个域名有多个IP，这就是自动重连的来源。</li>
<li>如果还没有查询到就递归调用next查询，直到查询到为止</li>
<li>一切next都没有枚举到，抛出NoSuchElementException，退出<br><br><br>如果Proxy为HTTP：</li>
<li>设置socket的ip为代理地址的ip</li>
<li>设置socket的端口为代理地址的端口</li>
<li>一切next都没有枚举到，抛出NoSuchElementException，退出<br><br></li>
</ol>
<h4 id="2-连接socket链路（RealConnection）"><a href="#2-连接socket链路（RealConnection）" class="headerlink" title="2.连接socket链路（RealConnection）"></a>2.连接socket链路（RealConnection）</h4><p>当地址，端口准备好了，就可以进TCP连接了（也就是三次握手），步骤如下：</p>
<ol>
<li>如果连接池中已经存在连接，就从中取出(get)RealConnection,如果没有命中就进入下一步</li>
<li>根据选择的路线（Route），调用Platform.get().connectSokcet选择当前平台Runtime下最好的socket库进行握手</li>
<li>强建立成功的RealConnection放入（put）连接池缓存</li>
<li>如果存在TLS，就根据SSL版本与证书进行安全握手</li>
<li>构造HttpStream并维护刚刚的socket连接，管理建立完成。</li>
</ol>
<h4 id="3-释放socket链路（release）"><a href="#3-释放socket链路（release）" class="headerlink" title="3.释放socket链路（release）"></a>3.释放socket链路（release）</h4><p>如果不再需要（比如通信完成，连接失败）此链路，释放连接（也就是TCP断开）</p>
<ol>
<li>尝试从缓存的连接池中删除（remove）</li>
<li>如果没有命中缓存，就直接调用jdk的socket关闭</li>
</ol>
<h4 id="HTTP请求序列化-反序列化"><a href="#HTTP请求序列化-反序列化" class="headerlink" title="HTTP请求序列化/反序列化"></a>HTTP请求序列化/反序列化</h4><h5 id="1-获得HTTP流（httpStream）"><a href="#1-获得HTTP流（httpStream）" class="headerlink" title="1.获得HTTP流（httpStream）"></a>1.获得HTTP流（httpStream）</h5><p>以下为无缓存，无多次302跳转，网络良好，HTTP/1.1下的GET访问实例分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">httpStream = connect();</span><br></pre></td></tr></table></figure></p>
<p>在connect()有非常重要的一步，它通过okio库与远程socket建立了I/O连接，为了更好的理解，我们可以把它看成管道：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//source 用于获取response</span></span><br><span class="line">source = Okio.buffer(Okio.source(rawSocket));</span><br><span class="line"><span class="comment">//sink用于write buffer到server</span></span><br><span class="line">sink = Okio.buffer(Okio.sink(rawSocket));</span><br></pre></td></tr></table></figure></p>
<p>OkHttp的I/O使用的是Okio库：</p>
<ul>
<li>Buffer：Buffer是可变字节，类似于byte[],相当于传输介质</li>
<li>source： source是Okio库中的输入组件，类似于inputStream,经常在下载中用到。它的重要方法是read(Buffer sink, long byteCount),从流中读取数据。</li>
<li>sink：sink是okio库中的io输入组件，类似于outputStream，经常用于写到file/socket，它的最重要方法是void write(Buffer source, long byteCount),写数据到Buffer中<br>如果把连接看成管道，-&gt;为管道的方向，如下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sink -&gt; Socket/File</span><br><span class="line">Source &lt;- Socket/File</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-拼装Raw请求与Headers-writeRequestHeaders"><a href="#2-拼装Raw请求与Headers-writeRequestHeaders" class="headerlink" title="2.拼装Raw请求与Headers(writeRequestHeaders)"></a>2.拼装Raw请求与Headers(writeRequestHeaders)</h4><p>我们通过Rquest.Builder构建了简陋的请求后，可能需要进行一些修饰，这时需要使用interceptors对Request进行进一步的拼装了。<br>拦截器是OkHttp中强大的流程装置，它可以用来监控log，修改请求，修改结果，甚至是对用户透明的GZIP压缩。<br>在OkHttp中，内部维护了一个Interceptors的List，通过InterceptorChain进行多次拦截修改操作。<br><img src="http://7xvn7e.com1.z0.glb.clouddn.com/201608081822.png" alt="Mark-Down"></p>
<p>请求代码如下，是自增递归(recursive)调用Chain.process(),直到interceptors().size()中的拦截器全部调用完。</p>
<ol>
<li>递归调用interceptors，依次入栈对response进行处理</li>
<li>当全部递归出栈完成后，移交给网络模块（getResponse）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(index &lt; client.interceptors().size())&#123;</span><br><span class="line">	Interceptor.Chain chain = <span class="keyword">new</span> ApplicationInterceptorChain(index + <span class="number">1</span>, request,forWebSocket);</span><br><span class="line">	Interceptor interceptor = client.interceptors().get(index);</span><br><span class="line">	<span class="comment">//递归调用Chain。process()</span></span><br><span class="line">	Response interceptedResponse = interceptor.intercept(chain);</span><br><span class="line">	<span class="keyword">if</span>(interceptedResponse == <span class="keyword">null</span>)&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"application interceptor"</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> interceptedResponse;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> getResponse(request, forWebSocket);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来是正式的网络请求getResponse()，此步骤通过http协议规范将对象中的数据信息序列化为Raw文本：</p>
<ol>
<li>在OkHttp中，通过RequestLine，Request，HttpEngine，Header等参数进行序列化操作，也就是拼装参数为socketRaw数据。拼装方法也比较暴力，直接按照RFC协议要求的格式进行concat输出就实现了<br>2.通过sink写入write到socket连接</li>
</ol>
<h4 id="1-3-获得响应（readResponseHeaders-Bod）"><a href="#1-3-获得响应（readResponseHeaders-Bod）" class="headerlink" title="1.3 获得响应（readResponseHeaders/Bod）"></a>1.3 获得响应（readResponseHeaders/Bod）</h4><p>此步骤根据获取到的Socket纯文本，解析为Response对象，我们可以看成是一个反序列（通过http协议将Raw文本转成对象）的过程：<br>拦截器的设计：</p>
<ol>
<li>自定义网络拦截器请求进行递归入栈</li>
<li><p>在自定义网络拦截器的intercept中，调用NetworkInterceptorChain的proceed（request），进行真正的网络请求（readNetWorkResponse）</p>
</li>
<li><p>接自定义请求递归出栈<br>网络读取（readNetworkResponse）分析：<br>1.读取Raw的第一行，并反序列化为StatusLine对象</p>
</li>
<li>以Transfer-Encoding:chuncked的模式传输并组装Body<br>伪代码如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(RawData &lt;- RemoteChannel(www.xx.com, <span class="number">80</span>) <span class="comment">//读取远程的Raw</span></span><br><span class="line">map(<span class="function">func <span class="title">NetworkInterceptorChains</span><span class="params">()</span>)<span class="comment">//云处理</span></span><br><span class="line"><span class="comment">//这里的source应用了HttpEngine，并重写了read方法</span></span><br><span class="line">.<span class="title">map</span><span class="params">(func getTransferStream&#123;&#125;)</span></span><br><span class="line"><span class="comment">// 根据source拼装body对象</span></span><br><span class="line">.<span class="title">map</span><span class="params">(func RealResponseBody()</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>接下来进行释放socket连接。<br>现在我们就获得response对象，进行进一步Gson操作。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/08/08/源码分析OKHttp/" data-id="cius4sg3e000ii4gfjf5bjutt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-doc-ppt-online" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/08/05/doc-ppt-online/" class="article-date">
  <time datetime="2016-08-05T02:07:27.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/doc-ppt-online/">在线预览ppt doc</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="打造自己在在线文档浏览"><a href="#打造自己在在线文档浏览" class="headerlink" title="打造自己在在线文档浏览"></a>打造自己在在线文档浏览</h2><h4 id="Apache-POI"><a href="#Apache-POI" class="headerlink" title="Apache POI"></a>Apache POI</h4><p>对在线文档浏览的误会，刚开始我选择了POI项目<br>Apache Poi下载地址：<a href="http://poi.apache.org/download.html" target="_blank" rel="external">http://poi.apache.org/download.html</a><br>我使用的版本是稳定版poi-bin-3.14.zip </p>
<h4 id="ApachePoi组件"><a href="#ApachePoi组件" class="headerlink" title="ApachePoi组件"></a>ApachePoi组件</h4><ul>
<li>POIFS（较差混淆技术实现文件系统）：此组件是所有其他POI元件的基本因素。它被用来明确地读取不同的文件。</li>
<li>HSSF（可怕的电子表格格式）：它被用来读取和写入MS-Excel文件的xls格式。</li>
<li>XSSF（XML格式）：它是用于MS-Excel中XLSX文件格式。</li>
<li>HPSF (可怕的属性设置格式):它用来提取MS-Office文件属性设置。</li>
<li>HWPF(可怕的字处理格式) ：它是用来读取和写入MS-Word的文档扩展名的文件。</li>
<li>XWPF(XML字处理格式):它是用来读取和写入MS-Word的docx扩展名的文件。</li>
<li>HSLF（可怕的幻灯片版式格式）：它是用于读取、创建和编辑PowerPoint演示文稿。</li>
<li>HDGF（可怕的图表格式）：它包含类和方法为MS-Visio的二进制文件。</li>
<li>HPBF（可怕的出版商格式）：它被用来读取和写人MS-Publisher文件。</li>
</ul>
<h4 id="Open-Office"><a href="#Open-Office" class="headerlink" title="Open Office"></a>Open Office</h4><p>做浏览，其实是需要另一个OpenOffice的项目。<br>步骤：</p>
<ul>
<li>先将doc、ppt、xls转换成pdf</li>
<li>再用js调用pdf在线查看</li>
<li>主要借助的工具openoffice、jodconvert、viewjs</li>
</ul>
<h4 id="安装openoffice"><a href="#安装openoffice" class="headerlink" title="安装openoffice"></a>安装openoffice</h4><p><a href="http://www.openoffice.org/zh-cn/download/" target="_blank" rel="external">http://www.openoffice.org/zh-cn/download/</a></p>
<h4 id="JODConvert简介"><a href="#JODConvert简介" class="headerlink" title="JODConvert简介"></a>JODConvert简介</h4><p>JODConvert,是一个Java的OpenDocument文件转换器，可以进行许多文件格式的转换。<br>它依赖于OpenOffice提供的服务来进行转换，它能将MS Office文档转换为PDF格式。<br><br><br>可以将JODConverter内嵌在Java应用程序里，也可以单独作为命令行由脚本调用，更可以应用为网页程序或者WebService以供网络应用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OfficeManager officeManager = <span class="keyword">new</span> DefaultOfficeManagerConfiguration( ).buildOfficeManager( );</span><br><span class="line"><span class="comment">//启动OpenOffice服务</span></span><br><span class="line">officeManager.start( );</span><br><span class="line"><span class="comment">//执行转换</span></span><br><span class="line">OfficeDocumentConverter converter = <span class="keyword">new</span> OfficeDocumentConverter(officeManager);</span><br><span class="line">converter.convert(<span class="keyword">new</span> File(“test.odt”), <span class="keyword">new</span> File(“test.pdf”));</span><br><span class="line"><span class="comment">//停止服务</span></span><br><span class="line">officeManager.stop( );</span><br></pre></td></tr></table></figure></p>
<p>OfficeManager是一个接口，主要定义了三个方法：</p>
<ul>
<li>public void start() 启动OpenOffice服务</li>
<li>public void stop() 停止OpenOffice服务</li>
<li>public void execute(OfficeTask task) 执行转换任务<br>DefaultOfficeManagerConfiguration是一个实现了OfficeManager接口的实体类，其提供了相关方法配置OpenOffice.org,比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DefaultOfficeManagerConfiguration <span class="title">setOfficeHome</span><span class="params">(String officeHome)</span> <span class="comment">//设置OpenOffice.org安装目录</span></span><br><span class="line"><span class="keyword">public</span> DefaultOfficeManagerConfiguration <span class="title">setConnectionProtocol</span><span class="params">(OfficeConnectionProtocol conn)</span> <span class="comment">//设置连接协议，确定使用管道通信，还是socket通信</span></span><br><span class="line"><span class="keyword">public</span> DefaultOfficeManagerConfiguration <span class="title">setTemplateProfileDir</span><span class="params">(File templateProfileDir)</span><span class="comment">//设置临时目录</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以查看JODConvert API手册查看其它配置。<br>配置完之后，必须要执行方法buildOfficeManager(),实现真正的配置。<br><br><br>OfficeDocumentConverter中主要包含convert方法，该方法实际上调用的是实现OfficeManager接口的类中的execute方法。</p>
<h4 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计"></a>算法设计</h4><p><img src="http://7xvn7e.com1.z0.glb.clouddn.com/JODConvert%E7%AE%97%E6%B3%95.png" alt="Mark-Down"></p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.converter.pdfConverter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.artofsolving.jodconverter.OfficeDocumentConverter;</span><br><span class="line"><span class="keyword">import</span> org.artofsolving.jodconverter.office.DefaultOfficeManagerConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.artofsolving.jodconverter.office.OfficeManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.converter.utils.FileUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenOfficePDFConverter</span> <span class="keyword">implements</span> <span class="title">PDFConverter</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  OfficeManager officeManager;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String OFFICE_HOME = <span class="string">"D:\\Program Files\\OpenOffice.org 3"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port[] = &#123;<span class="number">8100</span>&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">convert2PDF</span><span class="params">(String inputFile, String pdfFile)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(inputFile.endsWith(<span class="string">".txt"</span>))&#123;</span><br><span class="line">            String odtFile = FileUtils.getFilePrefix(inputFile)+<span class="string">".odt"</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">new</span> File(odtFile).exists())&#123;</span><br><span class="line">                System.out.println(<span class="string">"odt文件已存在！"</span>);</span><br><span class="line">                inputFile = odtFile;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    FileUtils.copyFile(inputFile,odtFile);</span><br><span class="line">                    inputFile = odtFile;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"文档不存在！"</span>);</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        startService();</span><br><span class="line">        System.out.println(<span class="string">"进行文档转换转换:"</span> + inputFile + <span class="string">" --&gt; "</span> + pdfFile);</span><br><span class="line">        OfficeDocumentConverter converter = <span class="keyword">new</span> OfficeDocumentConverter(officeManager);</span><br><span class="line">        converter.convert(<span class="keyword">new</span> File(inputFile),<span class="keyword">new</span> File(pdfFile));</span><br><span class="line">        stopService();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">convert2PDF</span><span class="params">(String inputFile)</span> </span>&#123;</span><br><span class="line">        String pdfFile = FileUtils.getFilePrefix(inputFile)+<span class="string">".pdf"</span>;</span><br><span class="line">        convert2PDF(inputFile,pdfFile);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DefaultOfficeManagerConfiguration configuration = <span class="keyword">new</span> DefaultOfficeManagerConfiguration();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"准备启动服务...."</span>);</span><br><span class="line">            configuration.setOfficeHome(OFFICE_HOME);<span class="comment">//设置OpenOffice.org安装目录</span></span><br><span class="line">            configuration.setPortNumbers(port); <span class="comment">//设置转换端口，默认为8100</span></span><br><span class="line">            configuration.setTaskExecutionTimeout(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">5L</span>);<span class="comment">//设置任务执行超时为5分钟</span></span><br><span class="line">            configuration.setTaskQueueTimeout(<span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">24L</span>);<span class="comment">//设置任务队列超时为24小时</span></span><br><span class="line">         </span><br><span class="line">            officeManager = configuration.buildOfficeManager();</span><br><span class="line">            officeManager.start();    <span class="comment">//启动服务</span></span><br><span class="line">            System.out.println(<span class="string">"office转换服务启动成功!"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ce) &#123;</span><br><span class="line">            System.out.println(<span class="string">"office转换服务启动失败!详细信息:"</span> + ce);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stopService</span><span class="params">()</span></span>&#123;</span><br><span class="line">          System.out.println(<span class="string">"关闭office转换服务...."</span>);</span><br><span class="line">            <span class="keyword">if</span> (officeManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">                officeManager.stop();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"关闭office转换成功!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>下载viewerjs<br><a href="http://viewerjs.org/releases/viewerjs-0.5.7.zip" target="_blank" rel="external">http://viewerjs.org/releases/viewerjs-0.5.7.zip</a><br>解压，将ViewerJS下的所有内容放置项目webapp下，<br>在同级目录下放置一个pdf(test.pdf),<br>如项目名是xxx<br>在线预览该pdf为<a href="http://localhost:8080/xxx/test.pdf" target="_blank" rel="external">http://localhost:8080/xxx/test.pdf</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/08/05/doc-ppt-online/" data-id="cius4sg260007i4gfd3czpwwa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java注解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/21/Java注解/" class="article-date">
  <time datetime="2016-07-21T03:24:17.000Z" itemprop="datePublished">2016-07-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/21/Java注解/">Java注解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="揭开Java注解的面纱"><a href="#揭开Java注解的面纱" class="headerlink" title="揭开Java注解的面纱"></a>揭开Java注解的面纱</h2><h4 id="什么是注解？"><a href="#什么是注解？" class="headerlink" title="什么是注解？"></a>什么是注解？</h4><p>从JDK1.5被引入到Java，它提供了一种机制，这种机制允许在编写代码的同时可以直接编写元数据。</p>
<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>注解就是代码的元数据，它们包含了代码自身的信息。<br>注解可以被用在包、类、方法、变量、参数上。<br>自Java8开始，有一种注解几乎可以被放在代码的任何位置，叫做类型注解。<br>被注解的代码并不会直接被注解影响。这只会向第三系统提供关于自己的信息以用于不同的需求。<br>注解会被编译至class文件中，而且在运行时被处理程序提取出来用于业务逻辑。<br>当然，创建在运行时不可用的注解也是可能的，甚至可以创建只在源文件中可用，在编译时不可用的注解。</p>
<h4 id="消费器"><a href="#消费器" class="headerlink" title="消费器"></a>消费器</h4><p>理解注解的目的以及如何使用它都会带来困难，因为注解本身并不包含任何功能逻辑，它们也不会影响自己注解的代码，那么，它们到底为什么而存在呢？<br>注解消费器，它们是利用被注解代码并根据注解信息产生不同行为的系统或者应用程序。<br>例如，在Java自带的内建注解（元注解）中，消费器是执行被注解代码的JVM。<br>还有其他，如JUnit，消费器是读取，分析被注解代码的Junit处理程序，它还可以决定测试单元和方法执行顺序。<br>消费器使用Java中的反射机制来读取和分析被注解的源代码。</p>
<h4 id="注解语法和元素"><a href="#注解语法和元素" class="headerlink" title="注解语法和元素"></a>注解语法和元素</h4><p>声明一个注解需要使用”@”作为前缀,这便向编译器说明，该元素为注解。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Annotation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotatedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述的注解名称为Annotation，它正在注解annotatedMethod方法。<br>编译器会处理它。注解可以以键值对的形式持有有很多元素，即注解的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Annoation</span>(</span><br><span class="line">	info = <span class="string">"I am an annotation"</span>,</span><br><span class="line">	counter = <span class="string">"55"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotatedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果注解只包含一个元素（或者只需要指定一个元素的值，其它使用默认），可以像这样声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Annotation</span>(<span class="string">"I am annotation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotatedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果没有元素需要被指定，则不需要括号。多个注解可以使用在同一代码上，例如类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Annoation</span>(info = <span class="string">"U a u O"</span>)</span><br><span class="line"><span class="meta">@Annoation</span>2</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AnnotatedClass</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="在什么地方使用"><a href="#在什么地方使用" class="headerlink" title="在什么地方使用"></a>在什么地方使用</h4><p>注解基本上可以在Java程序的每一个元素上使用：类、域、方法、包、变量，等待。<br>自Java8，诞生了通过类型注解的理念。<br>在此之前，注解是限于在前面讨论的元素的声明上使用。<br>从此，无论是类型哈市声明都可以使用注解，就像：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MyAnnotation</span> String str = <span class="string">"danibuiza"</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><p>注解可以满足许多要求，最普遍的是：</p>
<ul>
<li>向编译器提供信息：注解可以被编译器用来根据不同的规则产生警告，甚至错误。一个例子是Java8中@FunctionalInterface注解，这个注解使得编译器校验被注解的类，检查它是否是一个正确的函数式接口。</li>
<li>文档：注解可以被软件应用程序计算代码的质量例如：FindBugs、PMD或者自动生成报告，例如：用来Jenkins、Jira、Teamcity。</li>
<li>代码生成：注解可以使用代码中展示的元数据信息来自动生成代码或者xml文件，一个不错的例子是JAXB。</li>
<li>运行时处理：在运行时检查的注解可以用做不同的目的，像单元测试（Junit），依赖注入（Spring），校验，日志（Log4j），数据访问（Hibernate）等等。</li>
</ul>
<h4 id="内建注解"><a href="#内建注解" class="headerlink" title="内建注解"></a>内建注解</h4><p>Java语言自带了一系列的注解。<br>这个清单只涉及了Java语言最核心的包，未包含标准JRE中所有包和库如JAXB或Servlet规范。<br>以下讨论到的注解中有一些被称之为Meta注解，它们的目的注解其他注解，并且包含关于其他注解的信息。<br>@Retention：这个注解在其他注解上，并用来说明如何存储已被标记的注解。这是一种元注解，用来标记注解并提供注解的信息。可能的值是：</p>
<ul>
<li>SOURCE：表明这个注解会被编译器忽略，并只会保留在源代码中。</li>
<li>CLASS：表明这个注解会通过编译驻留在CLASS文件，但会被JVM在运行时忽略，正因为如此，其在运行时不可见。</li>
<li>RUNTIME：表示这个注解会被JVM获取，并在运行时通过反射获取。</li>
</ul>
<p>@Target：这个注解用于限制某个元素可以被注解的类型。例如：</p>
<ul>
<li>ANNOTATION_TYPE 表示该注解可以应用到其他注解上</li>
<li>CONSTRUCTOR 表示可以使用到构造器上</li>
<li>FIELD 表示可以使用到域或属性上</li>
<li>LOCAL_VARIABLE表示可以使用到局部变量上</li>
<li>METHOD可以使用到方法级别的注解上</li>
<li>PACKAGE可以使用到包声明上</li>
<li>PARAMETER可以使用到方法的参数上</li>
<li>TYPE可以使用到一个类的任何元素上</li>
</ul>
<p>@Documented：被注解的元素将会作为Javadoc产生的文档中的内容。<br>注解都默认不会成为文档中的内容。<br>这个注解可以对其它注解使用。<br>@Inherited：在默认情况下，注解不会被子类继承。<br>被此注解会被所有子类继承。这个注解可以对类使用<br>@Deprecated：说明被标记的元素不应该再度使用。<br>这个注解会让编译器产生警告消息。<br>可以使用到方法，类和域上。<br>相应的解释和原因，包括另一个可取代的方法应该同时和这个注解使用。<br>@SuppressWarnings：说明编译器不会针对指定的一个或多个原因产生警告。<br>例如：如果我们不想因为存在尚未使用的私有方法而得到警告可以这样做。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">myNotUsedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通常，编译器会因为没调用该方法而产生警告；用了注解印制了这种行为。该注解需要一个或多个参数来指定抑制的警告类型。<br>@Override：向编译器说明被注解元素是重写的父类的一个元素。在重写父类元素的时候此注解并非强制性的，不过可以在重写错误时帮助编译器产生错误以提醒我们。<br>@SafeVarargs：断言方法或者构造器的代码不会对参数进行不安全的操作。在Java的后续版本中，使用这个注解时将会令编译器产生一个错误在编译期间防止潜在的不安全操作。</p>
<h4 id="Java-8与注解"><a href="#Java-8与注解" class="headerlink" title="Java 8与注解"></a>Java 8与注解</h4><p>Java8带来了一些优势，同样注解框架的能力也得到了提升。<br>@Repeatable注解，关于类型注解的声明，函数式接口注解@FunctionInterface（与Lambda结合使用）。<br>*@Repeatable：说明该注解标识的注解可以多次使用到同一个元素的声明上。<br>看一个使用的例子。首先我们创造一个能容纳重复的注解的容器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE_USE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RepeatedValues&#123;</span><br><span class="line">	CanBeRepeated[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，创建注解本身，然后标记@Repeatable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE_USE)</span><br><span class="line"><span class="meta">@Repeatable</span>(RepeatedValues.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CanBeRepeated&#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，我们可以这样重复地使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CanBeRepeated</span> (<span class="string">"the color is green"</span>)</span><br><span class="line"><span class="meta">@CanBeRepeated</span> (<span class="string">"the color is red"</span>)</span><br><span class="line"><span class="meta">@CanBeRepeated</span> (<span class="string">"the color is blue"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatableAnnotated</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们尝试去掉@Repeatable<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE_USE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CannotBeRepeated</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CanBeRepeated</span>(<span class="string">"info"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatableAnnotatedWrong</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>自Java8开始，我们可以在类型上使用注解。<br>由于我们在任何地方都可以使用类型，包括new操作符，casting,implements,throw等等。<br>注解可以改善对Java代码的分析并且保证更加健壮的类型检查。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function">pubilc <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">//type def</span></span><br><span class="line">	<span class="meta">@TypeAnnotated</span></span><br><span class="line">	String cannotBeEmpty = <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//type</span></span><br><span class="line">	List&lt;<span class="meta">@TypeAnnotated</span> String&gt; myList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//values</span></span><br><span class="line">	String myString = <span class="keyword">new</span> <span class="meta">@TypeAnnotated</span> String(<span class="string">"this is annotated in java 8"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodAnnotated</span><span class="params">(@TypeAnnotated <span class="keyword">int</span> parameter)</span></span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"do nothing"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>@FunctionalInterfce:这个注解表示一个函数式接口元素。<br>函数式接口是一种只有一个抽象方法（非默认）的接口。<br>编译器会检查被注解元素，如果不符，就会产生错误。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">MyCustomInterface myFuncInterface = <span class="keyword">new</span> MyCustomInterface()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> param)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> param * <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line">MyCustomInterface myFuncInterfceLambdas = (x) -&gt; (x * <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyCustomInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">doSomething</span><span class="params">(<span class="keyword">int</span> param)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个注解可以被使用到类、接口、枚举和注解本身。<br>它的被JVM保留并在runtime可见，这个是它的声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(value = RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value = TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface</span><br></pre></td></tr></table></figure></p>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><p>首先，定义一个注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotationClass</span><br></pre></td></tr></table></figure></p>
<p>这样创建了一个新的注解类型名为CustomAnnotationClass。<br>关键字@interface说明这是一个自定义注解的定义。</p>
<p>之后，你需要为此注解定义一对强制性的属性，保留策略和目标。<br>还有一些其他属性可以定义，不过两个是最基本和重要的。<br>所以，我们为自定义的注解设置属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotationClass implements CustomAnnotationMethod</span><br></pre></td></tr></table></figure></p>
<p>在保留策略中RUNTIME告诉编译器这个注解应该被JVM保留，并且能通过反射在运行时分析。<br>通过TYPE我们又设置该注解可以被使用到任何类的元素上。<br>之后，我们定义两个注解的成员：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotationClass</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "xxxx"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">date</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上我们仅定义了默认值为’xxxx’的author属性和没有默认值的date属性。<br>我们应强调所有的方法声明都不能有参数和throw语句。<br>这个返回值的类型被限制为之前提过的字符串、类、枚举，注解和存储这些类型的数组。<br>现在我们可以像这样使用刚创建的自定义注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CustomAnnotationClass</span>(date = <span class="string">"2014-05-05"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedClass</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在另一种类似的用法中我们可以创建一种注解方法的注解，使用Target METHOD：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CustomAnnotationMethod</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "xxxx"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">date</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种注解可以使用在方法声明上：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CustomAnnotationMethod</span>(date = <span class="string">"2016-07-21"</span>, descripton = <span class="string">"annotated method"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">annotatedMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"nothing niente"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@CustomAnnotationMethod</span>(author = <span class="string">"Jimmy"</span>, date = <span class="string">"2016-07-21"</span>, description = <span class="string">"annotated method"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">annotatedMethodFromAFriend</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">"nothing niente"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有很多其他属性可以用在自定义注解上，但是目标（Target）和保留策略（Retention Policy）是最重要的两个。</p>
<h4 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h4><p>Java反射API包含了许多方法在运行时从类、方法或者其它元素获取注解。<br>接口AnnotatedElement包含了大部分重要的方法，如下：</p>
<ul>
<li>getAnnotations(): 返回该元素的所有注解，包括没有显示定义该元素上的注解。</li>
<li>isAnnotationPresent(annotation):检查传入的注解是否存在于当前元素。</li>
<li>getAnnotation(class):按照传入的参数获取指定类型的注解。返回null说明当前元素不带有此注解。<br>class通过java.lang.Class被实现，java.lang.reflect.Method和java.lang.reflect.Field，所以可以基本上被和任何Java元素使用。<br>现在写一个程序，从一个类和它的方法中读取所有的存在的注解：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">	Class&lt;AnnotatedClass&gt; object = AnnotatedClass.class;</span><br><span class="line">	Annotation[] annotations = object.getAnnotations();</span><br><span class="line">	<span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">		System.out.println(annotation);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(object.isAnnotationPresent(CustomAnnotationClass.class))&#123;</span><br><span class="line">		Annotation annotation = object.getAnnotation(CustomAnnotationClass.class);</span><br><span class="line">		System.out.println(annotation);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>( Method method : object.getDeclatredMethods())&#123;</span><br><span class="line">		<span class="keyword">if</span>(method.isAnnotationPresent(CustomAnnnotationMethod.class))&#123;</span><br><span class="line">			Annotation annotation = method.getAnnotation(CustomAnnotionMethod.class);</span><br><span class="line">			System.out.println(annotation);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在这个程序中，可以看到getAnnotations()方法来获取所有某个对象（方法、类）上的所有注解的用法。<br>展示了怎样使用isAnnotationPresent()方法和getAnnotation()方法检查是否存在特定的注解，和如何获取它。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/07/21/Java注解/" data-id="cius4sg1q0002i4gfh8460uiq" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-FFMpeg入门" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/16/FFMpeg入门/" class="article-date">
  <time datetime="2016-07-16T07:27:11.000Z" itemprop="datePublished">2016-07-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/16/FFMpeg入门/">FFMpeg入门</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="ffplay文件概览"><a href="#ffplay文件概览" class="headerlink" title="ffplay文件概览"></a>ffplay文件概览</h4><p><img src="http://7xvn7e.com1.z0.glb.clouddn.com/ffpeg_struct.png" alt="Mark-Down"></p>
<h5 id="libavcodec"><a href="#libavcodec" class="headerlink" title="libavcodec"></a>libavcodec</h5><ul>
<li>allcodecs.c 简单的注册类函数</li>
<li>avcodec.h 编解码相关结构定义和函数原型声明</li>
<li>dsputil.c 限幅数组初始化</li>
<li>dsputil.h 限幅数组声明</li>
<li>imgconvert.c 颜色空间转换相关函数实现</li>
<li>imgconvert_template.h 颜色空间转换相关结构体定义和函数实现</li>
<li>msrle.c 视频RLE行程长度压缩算法解码库</li>
<li>truespeech.c 语音TrueSpeech算法解码库</li>
<li>truespeech_data.h 语音TrueSpeech算法解码常量数组</li>
<li>utils_codec.c 一些解码相关的工具类函数的实现</li>
</ul>
<h5 id="libavformat"><a href="#libavformat" class="headerlink" title="libavformat"></a>libavformat</h5><ul>
<li>allformats.c 简单注册类函数</li>
<li>avformat.h 文件和媒体格式相关结构体定义和函数原型声明</li>
<li>avidec.c AVI文件解析类函数</li>
<li>avio.c 无缓冲数据IO相关函数实现</li>
<li>avio.h 无缓冲数据IO相关结构体定义和函数实现</li>
<li>aviobuf.c 有缓冲数据IO相关函数实现</li>
<li>cutils.c 两个简单的字符串操作函数</li>
<li>file.c 文件IO相关函数</li>
<li>utils_format.c 文件和媒体格式相关的工具类函数的实现</li>
</ul>
<h5 id="libavutil"><a href="#libavutil" class="headerlink" title="libavutil"></a>libavutil</h5><ul>
<li>avutil.h 简单的像素格式宏定义</li>
<li>bswap.h 简单的大小端转换函数的实现</li>
<li>common.h 公共的宏定义和简单函数的实现</li>
<li>mathematics.h 一个简单的数学运算函数(A*B/C)</li>
<li>rational.h 用两整数表示分数相关函数</li>
</ul>
<p>berrno.h 错误码定义<br>ffplay.c 总控文件</p>
<h4 id="播放器一般原理"><a href="#播放器一般原理" class="headerlink" title="播放器一般原理"></a>播放器一般原理</h4><p>七个模块按广度顺序：读文件模块、解复用模块、视频解码模块、音频解码音频、颜色空间转换模块、视频显示模块，音频播放模块。<br><img src="http://7xvn7e.com1.z0.glb.clouddn.com/directshow.png" alt="Mark-Down"></p>
<p>播放器有关的filter粗略的分为五类，分别是SourceFilter,DemuxFilter,DecoderFilter,ColorSpaceConverterFilter, RenderFilter。<br>SourceFilter源过滤器的作用是为下级DemuxFilter以包的形式源源不断的提供数据流。在通常情况下，我们有多种方式可以获得数据流，一种是从本地文件中读取，一种是从网上获取，SourceFilter另外一个作用就是屏蔽读本地文件和获取网络数据的差别，在下一级的DemuxFilter看来，本地文件和网络数据是一样的。<br>DemuxFilter解复用过滤器的作用是识别文件类型，媒体类型，分离出各媒体原始数据流，打上时钟信息后送给下级DecodeFilter。为识别出不同的文件类型和媒体类型，常规的做法是读取一部分数据，然后遍历解复用过滤器支持的文件格式和媒体数据格式，做匹配来确定是哪种文件类型，哪种媒体类型；有些媒体类型的原始数据外面还有其他的信息，比如时间、包大小、是否完整包等等。DemuxFilter解析数据包后取出原始数据，有些类型的媒体不管是否是完整包都立即送往下级DecodeFilter，有些类型的媒体要送完整数据包，此时可能有一些数据包拼接的动作；当然时钟信息的计算也是DemuxFilter的工作内容，这个时钟用于各媒体之间的同步。在本例中，AVISplitter是DemuxFilter。<br>DecoderFilter解码过滤器的作用就是解码数据包，并且把同步时钟信息传递下去。对视频媒体而言，通常是解码成YUV数据，然后利用显卡硬件直接支持YUV格式数据Overlay快速显示的特性让显卡极速显示。YUV格式是一个统称，常见的有YV12、YUY2，UYVY等等。有些非常古老的显卡和嵌入式系统不支持YUV数据显示，那就要转换成RGB格式的数据，每一帧的每一个像素点都要转换，分别计算RGB分量，并且因为转换是浮点运算，虽然有定点算法，还是要耗掉相当一部分CPU，总体上效率底下；对音频媒体而言，通常是解码成PCM数据，然后送给声卡直接输出。在本例中，AVI Decompress和ACM Warper是DecoderFilter。<br>ColorSpaceConverterFilter颜色空间转换过滤器的作用是把视频解码器解码出来的数据转换成当前显示系统支持的颜色格式。通常视频解码器解码出来的是YUV数据，PC系统是直接支持YUV格式的，也支持RGB格式，有些嵌入式系统只支持RGB格式的。在本例中，视频解码器出来的是RGB8格式的数据，ColorSpaceConverterFilter把RGB8转换成RGB32显示。<br>RenderFilter渲染过滤器的作用就是在适当的时间渲染相应的媒体，对视频媒体就是直接显示图像，对音频就是播放声音。视音频同步的策略方法有好几种，其中最简单的一种就是默认视频和音频基准时间相同，这时音频可以不打时钟信息，通过计算音频的采样频率，量化bit数，声道数等基本参数就知道音频PCM的数据速率，按照这个速率往前播放即可；视频必须要使用同步时钟信息来决定什么时候显示。DirectShow采用一个有序链表，把接收到的数据包放进有序链表中，启动一个定时器，每次定时器时间到就扫描链表，比较时钟信息，或者显示相应的帧，或者什么也不做，每次接收到新的数据帧，首先判断时钟信息，如果是历史数据帧就丢弃，如果是将来显示数据帧就进有序链表，如果当前时间帧就直接显示。如此这样，保持视频和音频在人体感觉误差范围内相对的动态同步。在本例中VideoRendeDirectSoundDevice是RenderFilter，同时也是SinkFilter。<br>GraphEdit应用程序可以看成是一个支撑平台，支撑框架。它容纳各种Filter，在Filter间的传递一些通讯消息，控制Filter的运行（启动暂停停止），维护Filter运行状态。GraphEdit就像超级大管家一样，既维护管理看得见的Filter，又维护管理看不见的运行支撑环境。</p>
<h4 id="ffplay播放器原理"><a href="#ffplay播放器原理" class="headerlink" title="ffplay播放器原理"></a>ffplay播放器原理</h4><h4 id="ffplay架构概述"><a href="#ffplay架构概述" class="headerlink" title="ffplay架构概述"></a>ffplay架构概述</h4><h4 id="ffplay主要改动"><a href="#ffplay主要改动" class="headerlink" title="ffplay主要改动"></a>ffplay主要改动</h4><h4 id="SDL显示视频"><a href="#SDL显示视频" class="headerlink" title="SDL显示视频"></a>SDL显示视频</h4><h4 id="SDL播放音频"><a href="#SDL播放音频" class="headerlink" title="SDL播放音频"></a>SDL播放音频</h4><h4 id="AVI文件格式简介"><a href="#AVI文件格式简介" class="headerlink" title="AVI文件格式简介"></a>AVI文件格式简介</h4><h4 id="MS-RLE压缩算法简介"><a href="#MS-RLE压缩算法简介" class="headerlink" title="MS RLE压缩算法简介"></a>MS RLE压缩算法简介</h4><h4 id="True-Speech压缩算法简介"><a href="#True-Speech压缩算法简介" class="headerlink" title="True Speech压缩算法简介"></a>True Speech压缩算法简介</h4><p><br><br><br><br></p>
<h2 id="libavutil剖析"><a href="#libavutil剖析" class="headerlink" title="libavutil剖析"></a>libavutil剖析</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/07/16/FFMpeg入门/" data-id="cius4sg1u0004i4gf36wdr5i9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-函数式编程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/27/函数式编程/" class="article-date">
  <time datetime="2016-06-27T03:04:00.000Z" itemprop="datePublished">2016-06-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/27/函数式编程/">函数式编程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="在Java的世界里，第一要素是“类”，而在函数式编程里，第一要素则是“函数”。"><a href="#在Java的世界里，第一要素是“类”，而在函数式编程里，第一要素则是“函数”。" class="headerlink" title="在Java的世界里，第一要素是“类”，而在函数式编程里，第一要素则是“函数”。"></a>在Java的世界里，第一要素是“类”，而在函数式编程里，第一要素则是“函数”。</h2><h2 id="何为函数式编程"><a href="#何为函数式编程" class="headerlink" title="何为函数式编程"></a>何为函数式编程</h2><p>函数式编程是一种编程范式（programming paradigm），也就是如何编写程序的方法论。<br>它属于“结构化编程”的一种，主要思想是想把运算过程尽量写成一系列嵌套的函数调用。<br>举例来说，现在有这样一个数学表达式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>+<span class="number">2</span>) * <span class="number">3</span> - <span class="number">4</span></span><br></pre></td></tr></table></figure></p>
<p>传统的过程式编写，可能这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> b = a * <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> c = b - <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<p>函数式编程要求使用函数，可以把这一过程定义为不同的函数，然后写成下面这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = subtract(multiply(add(<span class="number">1</span>,<span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>);</span><br></pre></td></tr></table></figure></p>
<p>这就是函数式编程</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ol>
<li><p>函数是第一等公民<br>函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123; <span class="built_in">console</span>.log(i);&#125;;</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].forEach(print);</span><br></pre></td></tr></table></figure>
</li>
<li><p>只用“表达式”，不用“语句”<br>“表达式”（expression）是一个单纯的运算过程，总是有返回值；<br>“语句”（statement）是执行某种操作，没有返回值。<br>函数式编程要求，只使用表达式，不使用语句。<br>也就是说，每一步都是单纯的运算，而且都有返回值。</p>
</li>
<li>没有“副作用”<br>“副作用”是指，函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。<br>函数式编程强调没有“副作用”，意味着函数要保持独立，所有功能就是返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</li>
<li>不修改状态<br>在其他类型的语言中，变量往往用来保存“状态”（state）。<br>不修改变量，意味着状态不能保存在变量中。<br>函数式编程使用参数保存状态，最好的例子就是递归。</li>
<li>引用透明<br>引用透明（Referential transparency），指的是函数的运行不依赖于外部变量或“状态”，<br>只依赖于输入的参数，任何时候只要参数相同，引用函数所得的返回值总是相同的。</li>
</ol>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><ol>
<li>代码简洁，开发快速</li>
<li>接近自然语言，易于理解</li>
<li>更方便的代码管理<br>函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。<br>因此，每一个函数都可以被看做独立单元，很有利于进行单元测试和除错，以及模块化组合。</li>
<li>易于“并发”<br>函数式编程不需要考虑“死锁”，因为它不修改变量，所以根本不存在“锁”线程的问题。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = Op1();</span><br><span class="line"><span class="keyword">var</span> s2 = Op2();</span><br><span class="line"><span class="keyword">var</span> s3 = concat(s1, s2);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>由于s1和s2互不干扰，不会修改变量，谁先执行是无所谓的，所以可以放心地增加线程，把它们分别放在两个线程上完成。</p>
<ol>
<li>代码的热升级<br>函数式编程没有副作用，只要保证接口不变，内部实现是外部无关的。<br>所以，可以在运行状态下直接升级代码不需要重启。<br><br><br><br><h2 id="扫盲"><a href="#扫盲" class="headerlink" title="扫盲"></a>扫盲</h2>函数式编程是一种编程模型，他将计算机运算看做是数学中函数的计算，并且避免了状态以及变量的概念。<br>在函数式编程中，我们要做的就是把函数传来穿去，而这个，说成术语，我们把他叫做高阶函数。<br>f(x) = y ，那么这个函数无论在什么场景下，都会得到同样的结果，这个我们称之为函数的确定性。<br>函数式编程的抽象本质则是将函数也作为一个抽象单位，而反映成代码形式，则是高阶函数。<br>循环是在描述我们该如何地去解决问题。<br>递归是在描述这个问题的定义。<br>其实尾递归就是不要保持当前递归函数的状态，而把需要保持的东西全部用参数给传到下一个函数里，这样就可以自动清空本次调用的栈空间。<h2 id="Java8-Lambda表达式"><a href="#Java8-Lambda表达式" class="headerlink" title="Java8 Lambda表达式"></a>Java8 Lambda表达式</h2>匿名内部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandTest</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ProcessArray pa = <span class="keyword">new</span> ProcessArray();</span><br><span class="line">		<span class="keyword">int</span>[] target = &#123;<span class="number">3</span>, -<span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">		<span class="comment">//处理数组，具体处理行为取决于匿名内部类</span></span><br><span class="line">		pa.process(target, <span class="keyword">new</span> Command()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="keyword">int</span>[] target)</span></span>&#123;</span><br><span class="line">				<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="keyword">int</span> tmp: target)&#123;</span><br><span class="line">					sum += tmp;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(<span class="string">"数组元素的总和："</span> + sum);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>Lambda表达式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">CommandTest2</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		ProcessArray pa = <span class="keyword">new</span> ProcessArray();</span><br><span class="line">		<span class="keyword">int</span>[] array = [<span class="number">3</span>, -<span class="number">4</span>, <span class="number">6</span>, <span class="number">4</span>];</span><br><span class="line">		<span class="comment">//处理数组，具体处理行为取决于匿名内部类</span></span><br><span class="line">		pa.process(array, (<span class="keyword">int</span>[] target)-&gt;&#123;</span><br><span class="line">			<span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> tmp : target)&#123;</span><br><span class="line">				sum += tmp;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"数组元素的总和："</span> + sum);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Lambda表达式的主要作用就是代替匿名内部类的繁琐语法。</span><br><span class="line">它由三部分组成：</span><br><span class="line">形参列表。形参列表允许省略形参类型。如果形参列表中只有一个参数，甚至连形参列表的圆括号也可以省略。</span><br><span class="line">箭头（-&gt;）必须通过英文中画线号和大于符号组成。</span><br><span class="line">代码块。如果代码块只包含一条语句，Lambda表达式允许省略代码块的花括号，那么这条语句就不要用花括号表示语句结束。</span><br><span class="line">Lambda代码块只有一条<span class="keyword">return</span>语句，甚至可以省略<span class="keyword">return</span>关键字。</span><br><span class="line">```java</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eatable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">taste</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">(String weather)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Addable</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaQs</span></span>&#123;</span><br><span class="line">	<span class="comment">//调用该方法需要Eatable对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Eatable e)</span></span>&#123;</span><br><span class="line">		System.out.println(e);</span><br><span class="line">		e.taste();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用该方法需要Flyable对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drive</span><span class="params">(Flyable f)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"我正在驾驶："</span> + f);</span><br><span class="line">		f.fly(<span class="string">"碧空如洗的晴日"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//调用该方法需要Addable对象</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Addable add)</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"5与3的和为： "</span> + add.add(<span class="number">5</span>, <span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		LambdaQs lq = <span class="keyword">new</span> LambdaQs();</span><br><span class="line">		<span class="comment">//Lambda表达式的代码只有一条语句，可以省略花括号</span></span><br><span class="line">		lq.eat(()-&gt;System.out.println(<span class="string">"苹果的味道不错！"</span>));</span><br><span class="line">		<span class="comment">//Lambda表达式的形参列表只有一个形参，可以省略圆括号</span></span><br><span class="line">		lq.drive(weather-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">"今天天气是："</span> + weather);</span><br><span class="line">			System.out.println(<span class="string">"直升飞机飞行平稳"</span>);</span><br><span class="line">		&#125;);</span><br><span class="line">		<span class="comment">//Lambda表达式的代码块只有一条语句，可以省略花括号</span></span><br><span class="line">		<span class="comment">//代码块只有一条语句，即使该表达式需要返回值，也可以省略return关键字</span></span><br><span class="line">		lq.test((a, b)-&gt;a + b);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了保证Lambda表达式的目标类型是一个明确的函数式接口，可以由如下三种常见的方法：</p>
<ul>
<li>将Lambda表达式赋值给函数式接口类型的变量</li>
<li>将Lambda表达式作为函数式接口类型的参数传给某个方法</li>
<li>使用函数式接口对Lambda表达式进行强制类型转换</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/06/27/函数式编程/" data-id="cius4sg2i000ci4gfyxf5ivui" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-买买买网" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/23/买买买网/" class="article-date">
  <time datetime="2016-06-23T15:29:49.000Z" itemprop="datePublished">2016-06-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/23/买买买网/">买买买网</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><ol>
<li>电商行业的背景。买买买商城的介绍。搭建项目工程。SVN的使用。</li>
<li>框架的整合。后台管理商品列表的实现。分页插件。</li>
<li>后台管理。商品添加。商品类目的选择、图片上传、富文本编辑器的使用。</li>
<li>商品规格的实现。</li>
<li>商城前台系统的搭建。首页商品分类的展示。Jsonp。</li>
<li>cms系统的实现。前台打广告位的展示。</li>
<li>cms系统添加缓存。Redis。缓存同步。</li>
<li>搜索功能的实现。使用solr实现搜索。</li>
<li>商品详情页面的展示。</li>
<li>单点登录系统。Session共享。</li>
<li>购物车订单系统的实现。</li>
<li>nginx。反向代理工具。</li>
<li>redis集群的搭建、solr集群的搭建。系统的部署。</li>
<li>项目总结。</li>
</ol>
<h2 id="2016-06-23"><a href="#2016-06-23" class="headerlink" title="2016-06-23"></a>2016-06-23</h2><h4 id="电商行业技术特点"><a href="#电商行业技术特点" class="headerlink" title="电商行业技术特点"></a>电商行业技术特点</h4><ul>
<li>技术新</li>
<li>技术范围广</li>
<li>分布式</li>
<li>高并发、集群、负载均衡、高可用</li>
<li>海量数据</li>
<li>业务复杂</li>
<li>系统安全</li>
</ul>
<h4 id="买买买商城的模式"><a href="#买买买商城的模式" class="headerlink" title="买买买商城的模式"></a>买买买商城的模式</h4><p>买买买商城是一个综合性的B2C平台，类似京东商城、天猫商城。<br>会员可以在商城浏览商品、下订单、以及参加各种活动。<br>管理员、运营可以在平台后台管理系统中管理商品、订单、会员等。<br>客服可以在后台管理系统中处理用户的询问以及投诉。<br><img src="http://7xvn7e.com1.z0.glb.clouddn.com/B2C%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png" alt="Mark-Down"></p>
<h4 id="技术架构"><a href="#技术架构" class="headerlink" title="技术架构"></a>技术架构</h4><p><img src="http://7xvn7e.com1.z0.glb.clouddn.com/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84.png" alt="Mark-Down"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/06/23/买买买网/" data-id="cius4sg2h000bi4gfmnni3nqg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-UiAutomator环境搭建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/06/13/UiAutomator环境搭建/" class="article-date">
  <time datetime="2016-06-13T03:13:40.000Z" itemprop="datePublished">2016-06-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/06/13/UiAutomator环境搭建/">UiAutomator环境搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="必备条件"><a href="#必备条件" class="headerlink" title="必备条件"></a>必备条件</h2><p>JDK<br>Android SDK（API高于15）<br>Eclipse(安装ADT插件）<br>ANT（用于编译生成jar包）</p>
<h2 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h2><p>JAVA_HOME<br>ANDORID_HOME<br>ANT_HOME</p>
<h2 id="创建JAVA工程"><a href="#创建JAVA工程" class="headerlink" title="创建JAVA工程"></a>创建JAVA工程</h2><p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131123.png" alt="Mark-Down"></p>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131118.png" alt="Mark-Down"></p>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131119.png" alt="Mark-Down"></p>
<p><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131121.png" alt="Mark-Down"></p>
<h2 id="编写测试代码"><a href="#编写测试代码" class="headerlink" title="编写测试代码"></a>编写测试代码</h2><p>创建TestClass类，继承自UiAutomatorTestCase<br>编写testDemo()方法，添加测试用例</p>
<h2 id="生成AutoRunner的jar包"><a href="#生成AutoRunner的jar包" class="headerlink" title="生成AutoRunner的jar包"></a>生成AutoRunner的jar包</h2><ul>
<li>cmd命令 android list 查看API 大于15的SDK的ID值</li>
<li>android create uitest-project -n <name> -t <android-sdk-id> -p <path></path><br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131139.png" alt="Mark-Down"></android-sdk-id></name></li>
</ul>
<p>运行命令后，将会在工程的根目录下生成build.xml文件<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131140.png" alt="Mark-Down"></p>
<p>用ant命令编译生成jar cmd ant build<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131144.png" alt="Mark-Down"></p>
<h2 id="PUSH并运行jar"><a href="#PUSH并运行jar" class="headerlink" title="PUSH并运行jar"></a>PUSH并运行jar</h2><p>adb push <jar文件路径> data/local/tmp<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131147.png" alt="Mark-Down"></jar文件路径></p>
<p>adb shell uiautomator runtest <jar文件名> -c &lt;包名.类名&gt;<br><img src="http://121.43.152.226:8080/FirstMyEclipseProject/images/201606131148.png" alt="Mark-Down"></jar文件名></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://JimmyYao984.github.io/2016/06/13/UiAutomator环境搭建/" data-id="cius4sg1w0005i4gf1xkhzf2w" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/09/">九月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/08/">八月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/10/27/RBAC模型/">RBAC模型</a>
          </li>
        
          <li>
            <a href="/2016/09/16/安全加密认证基础知识/">安全加密认证基础知识</a>
          </li>
        
          <li>
            <a href="/2016/09/13/RX前传/">RX前传</a>
          </li>
        
          <li>
            <a href="/2016/08/08/源码分析OKHttp/">源码分析OKHttp</a>
          </li>
        
          <li>
            <a href="/2016/08/05/doc-ppt-online/">在线预览ppt doc</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Jimmy Yao<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>